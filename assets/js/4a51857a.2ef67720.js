"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[4801],{4269:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"tutorial/tutorial-beam-dynamics/for_students","title":"15. OCELOT for students","description":"Build intuition","source":"@site/docs/tutorial/tutorial-beam-dynamics/for_students.md","sourceDirName":"tutorial/tutorial-beam-dynamics","slug":"/tutorial/tutorial-beam-dynamics/for_students","permalink":"/docs/tutorial/tutorial-beam-dynamics/for_students","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/tutorial/tutorial-beam-dynamics/for_students.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15,"title":"15. OCELOT for students","description":"Build intuition"},"sidebar":"tutorialSidebar","previous":{"title":"14. Useful OCELOT functions","permalink":"/docs/tutorial/tutorial-beam-dynamics/small_useful_features"},"next":{"title":"16. Design HeRes Optics","permalink":"/docs/tutorial/tutorial-beam-dynamics/optics_design"}}');var i=t(4848),s=t(8453);const l={sidebar_position:15,title:"15. OCELOT for students",description:"Build intuition"},o="Ocelot for Students",r={},d=[{value:"Quadrupole Doublet",id:"quadrupole-doublet",level:2},{value:"Create a Simple Lattice",id:"create-a-simple-lattice",level:2},{value:"Plot Beta Functions",id:"plot-beta-functions",level:2},{value:"png",id:"png",level:2},{value:"Plot Trajectories for Better Understanding of Transverse Beam Dynamics",id:"plot-trajectories-for-better-understanding-of-transverse-beam-dynamics",level:2},{value:"png",id:"png-1",level:2},{value:"Bending Magnet: Quick Look at Dispersion",id:"bending-magnet-quick-look-at-dispersion",level:2},{value:"A Simple Lattice",id:"a-simple-lattice",level:3},{value:"Dispersion Visualization",id:"dispersion-visualization",level:3},{value:"Do Bending Magnets Focus the Beam?",id:"do-bending-magnets-focus-the-beam",level:2},{value:"Sector Dipole Magnet (<code>SBend</code>)",id:"sector-dipole-magnet-sbend",level:3},{value:"Rectangular Dipole Magnet (<code>RBend</code>)",id:"rectangular-dipole-magnet-rbend",level:3}];function c(e){const n={a:"a",annotation:"annotation",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",math:"math",mi:"mi",mn:"mn",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("small",{children:(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["This notebook was created by Sergey Tomin (",(0,i.jsx)(n.a,{href:"mailto:sergey.tomin@desy.de",children:"sergey.tomin@desy.de"}),"). April 2025."]})})}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ocelot-for-students",children:(0,i.jsx)(n.a,{href:"https://github.com/ocelot-collab/ocelot/blob/dev/demos/ipython_tutorials/interactive_beamline.ipynb",children:"Ocelot for Students"})})}),"\n",(0,i.jsxs)(n.p,{children:["This ",(0,i.jsx)(n.a,{href:"https://github.com/ocelot-collab/ocelot/blob/dev/demos/ipython_tutorials/interactive_beamline.ipynb",children:"tutorial"})," is aimed\nat students and beginners in accelerator physics.",(0,i.jsx)(n.br,{}),"\n","The idea is to keep it simple and interactive, helping you build intuition about how magnetic elements work."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"quadrupole-doublet",children:"Quadrupole Doublet"}),"\n",(0,i.jsx)(n.p,{children:"In this section, we will consider a simple beamline consisting of only a drift and two quadrupoles."}),"\n",(0,i.jsxs)(n.p,{children:["As usual, let's import the necessary Ocelot modules, the standard Python ",(0,i.jsx)(n.code,{children:"copy"})," library, and ",(0,i.jsx)(n.code,{children:"ipywidgets"})," for interaction with the physics model."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,i.jsx)(n.strong,{children:"Tip:"})," If you don't have the ",(0,i.jsx)(n.code,{children:"ipywidgets"})," module installed, just search online for installation instructions:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"pip install ipywidgets\n"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"create-a-simple-lattice",children:"Create a Simple Lattice"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"d = Drift(l=1.)\nqf = Quadrupole(l=0.2, k1=1)\nqd = Quadrupole(l=0.2, k1=-1)\ncell = [d, qf, d, qd, d]\n\nlat = MagneticLattice(cell)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"plot-beta-functions",children:"Plot Beta Functions"}),"\n",(0,i.jsxs)(n.p,{children:["Now we define a function that calculates and plots the beta functions for a simple lattice with a focusing and defocusing quadrupole.",(0,i.jsx)(n.br,{}),"\n","You can interactively change the quadrupole strengths using sliders (if using ",(0,i.jsx)(n.code,{children:"ipywidgets"}),"), and observe how the beta functions evolve."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def plot_betas(qf_k1=1.0, qd_k1=-1.0, save_path=None):\n    # Set quadrupole strengths\n    qf.k1 = qf_k1\n    qd.k1 = qd_k1\n\n    # Define initial Twiss parameters\n    tws0 = Twiss(beta_x=10, beta_y=10, alpha_x=0, alpha_y=0)\n\n    # Calculate Twiss parameters along the beamline\n    tws = twiss(lat, tws0, nPoints=20)\n\n    # Extract s-position and beta functions\n    sb = [tw.s for tw in tws]\n    bx = [tw.beta_x for tw in tws]\n    by = [tw.beta_y for tw in tws]\n\n    # Plot using Ocelot\'s built-in function (you can also use matplotlib directly)\n    fig, ax_xy = plot_API(lat, fig_name=f"Beta-functions: QF.k1={qf_k1:.2f}, QD.k1={qd_k1:.2f}", legend=False)\n    fig.suptitle(f"Beta-functions: QF.k1={qf_k1:.2f}, QD.k1={qd_k1:.2f}")\n\n    ax_xy.plot(sb, bx, "C1", label=r"$\\beta_x$")\n    ax_xy.plot(sb, by, "C2", label=r"$\\beta_y$")\n    ax_xy.set_ylabel(r"$\\beta_{x,y}$ [m]")\n    ax_xy.set_xlabel("S [m]")\n    ax_xy.legend()\n    if save_path:\n        fig.savefig(save_path)\n        plt.close(fig)\n    else:\n        plt.show()\n'})}),"\n",(0,i.jsx)(n.p,{children:"Interactive widget:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Create interactive sliders for the parameters\ninteract(\n    lambda qf_k1,qd_k1: plot_betas(qf_k1,qd_k1, save_path=None),\n    qf_k1=FloatSlider(min=-20, max=20, step=0.1, value=1.0),\n    qd_k1=FloatSlider(min=-20, max=20, step=0.1, value=-1.0),\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"png",children:(0,i.jsx)(n.img,{alt:"png",src:t(6144).A+"",width:"640",height:"480"})}),"\n",(0,i.jsx)(n.h2,{id:"plot-trajectories-for-better-understanding-of-transverse-beam-dynamics",children:"Plot Trajectories for Better Understanding of Transverse Beam Dynamics"}),"\n",(0,i.jsx)(n.p,{children:"Now let's plot particle trajectories with initial transverse offsets to better visualize how the beam evolves through the lattice."}),"\n",(0,i.jsxs)(n.p,{children:["We\u2019ll use two subplots: one for horizontal (",(0,i.jsx)(n.code,{children:"x"}),") and one for vertical (",(0,i.jsx)(n.code,{children:"y"}),") motion."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def plot_beam(qf_k1=1.0, qd_k1=-1.0, save_path=None):\n    qf.k1 = qf_k1\n    qd.k1 = qd_k1\n\n    x_coors = np.linspace(-0.01, 0.01, num=10)\n    y_coors = np.linspace(-0.01, 0.01, num=10)\n\n    p_list = [Particle(x=x, y=y) for x, y in zip(x_coors, y_coors)]\n    P = [copy.deepcopy(p_list)]\n    navi = Navigator(lat)\n    dz = 0.01\n\n    for _ in range(int(lat.totalLen / dz)):\n        tracking_step(lat, p_list, dz=dz, navi=navi)\n        P.append(copy.deepcopy(p_list))\n    fig, (ax_x, ax_y) = plot_API(lat, figsize=(10,6), legend=False, add_extra_subplot=True)\n    fig.suptitle(f"Particle Trajectories with Transverse Offsets: QF.k1={qf_k1:.2f}, QD.k1={qd_k1:.2f}")\n\n    for i in range(len(p_list)):\n        s = [p[i].s for p in P]\n        x = [p[i].x for p in P]\n        y = [p[i].y for p in P]\n        ax_x.plot(s, x, "C0")\n        ax_y.plot(s, y, "C1")\n\n    ax_x.set_ylabel("X [m]")\n    ax_y.set_ylabel("Y [m]")\n    ax_x.grid(True)\n    ax_y.grid(True)\n    if save_path:\n        fig.savefig(save_path)\n        plt.close(fig)\n    else:\n        plt.show()\n'})}),"\n",(0,i.jsx)(n.p,{children:"Add the interactive widget:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Create interactive sliders for the parameters\ninteract(\n    lambda qf_k1,qd_k1: plot_beam(qf_k1,qd_k1, save_path=None),\n    qf_k1=FloatSlider(min=-20, max=20, step=0.1, value=1.0),\n    qd_k1=FloatSlider(min=-20, max=20, step=0.1, value=-1.0),\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"png-1",children:(0,i.jsx)(n.img,{alt:"png",src:t(7174).A+"",width:"1000",height:"600"})}),"\n",(0,i.jsx)(n.h2,{id:"bending-magnet-quick-look-at-dispersion",children:"Bending Magnet: Quick Look at Dispersion"}),"\n",(0,i.jsx)(n.p,{children:"Let's take a look at transverse beam dynamics in a dipole magnet."}),"\n",(0,i.jsx)(n.h3,{id:"a-simple-lattice",children:"A Simple Lattice"}),"\n",(0,i.jsx)(n.p,{children:"We define a basic beamline composed of a drift\u2013dipole\u2013drift sequence:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"d = Drift(l=1)\nb1 = Bend(l=0.5, angle=5/180*np.pi, e1=0, e2=0)\ncell = [d, b1, d]\nlat2 = MagneticLattice(cell)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dispersion-visualization",children:"Dispersion Visualization"}),"\n",(0,i.jsx)(n.p,{children:"Now we\u2019ll create particles with zero initial transverse coordinates, but different momentum deviations, and observe how this affects their horizontal position.\nIn other words, we\u2019ll see dispersion in action \ud83d\ude0a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def plot_dipole_disp(angle=0.01, save_path=None):\n    # Set dipole parameters (angle in degrees -> radians)\n    b1.angle = angle * np.pi / 180\n    b1.e1 = 0 # edge focusing is 0 Basically it is SBend magnet\n    b1.e2 = 0 # edge focusing is 0 Basically it is SBend magnet\n    print(f"Lattice length: {lat2.totalLen:.2f} m")\n\n    # Create particles with momentum deviations (x = 0, y = 0)\n    p_coors = np.linspace(-0.01, 0.01, num=10)\n    p_list = [Particle(x=0, y=0, p=p, E=1) for p in p_coors]\n    P = [copy.deepcopy(p_list)]\n\n    # Navigator and tracking step size\n    navi = Navigator(lat2)\n    dz = 0.01\n\n    # Track particles through the lattice\n    for _ in range(int(lat2.totalLen / dz)):\n        tracking_step(lat2, p_list, dz=dz, navi=navi)\n        P.append(copy.deepcopy(p_list))\n\n    # Plot horizontal trajectories and momenta\n    fig, (ax_x, ax_p) = plot_API(lat2, figsize=(10,6), legend=False, add_extra_subplot=True)\n\n    fig.suptitle(f"Effect of Dispersion in a Dipole Magnet: Angle = {angle:.1f}")\n\n    colors = plt.cm.rainbow(np.linspace(0, 1, len(p_list)))[::-1]\n    for i in range(len(p_list)):\n        s = [p[i].s for p in P]\n        x = [p[i].x for p in P]\n        p_vals = [p[i].p for p in P]\n\n        ax_x.plot(s, x, color=colors[i])\n        ax_p.plot(s, p_vals, color=colors[i])\n\n    ax_x.set_ylabel("X [m]")\n    ax_p.set_ylabel("Relative Momentum p")\n    ax_x.set_ylim([-0.005, 0.005])\n\n    ax_x.grid(True)\n    ax_p.grid(True)\n    if save_path:\n        fig.savefig(save_path)\n        plt.close(fig)\n    else:\n        plt.show()\n'})}),"\n",(0,i.jsx)(n.p,{children:"Widget:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Create interactive sliders for the parameters\ninteract(\n    lambda angle: plot_dipole_disp(angle=angle, save_path=None),\n    angle=FloatSlider(min=-30, max=30, step=0.05, value=1.0),\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"png",src:t(9765).A+"",width:"1000",height:"600"})}),"\n",(0,i.jsx)(n.h2,{id:"do-bending-magnets-focus-the-beam",children:"Do Bending Magnets Focus the Beam?"}),"\n",(0,i.jsxs)(n.p,{children:["In this section, we investigate whether bending magnets can provide transverse focusing. We'll compare two common types of dipole magnets used in accelerator physics: the ",(0,i.jsx)(n.strong,{children:"sector dipole magnet"})," (",(0,i.jsx)(n.code,{children:"SBend"}),") and the ",(0,i.jsx)(n.strong,{children:"rectangular dipole magnet"})," (",(0,i.jsx)(n.code,{children:"RBend"}),"). Each has distinct edge geometries, which affect how the beam is focused or defocused in the transverse plane."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"sector-dipole-magnet-sbend",children:["Sector Dipole Magnet (",(0,i.jsx)(n.code,{children:"SBend"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"sector dipole"})," has its entrance and exit faces aligned ",(0,i.jsx)(n.strong,{children:"perpendicular to the reference trajectory"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"SBend",src:t(82).A+"",width:"512",height:"340"})}),"\n",(0,i.jsxs)(n.p,{children:["In the animation below, you can see how a beam propagates through an ",(0,i.jsx)(n.code,{children:"SBend"}),", and how the transverse position evolves due to the edge focusing."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Assuming these come from your simulation code\n# from your_code import Drift, SBend, MagneticLattice, Navigator, Particle, tracking_step\n\n# Setup lattice (this stays outside the function)\nd = Drift(l=1)\nb = SBend(l=0.5, angle=5/180*np.pi)\ncell = [d, b, d]\nlat3 = MagneticLattice(cell)\n\ndef plot_sbend_focus(angle=0.01, save_path=None):\n    b.angle = angle * np.pi / 180\n    b.e1 = 0\n    b.e2 = 0\n    x_coors = np.linspace(-0.01, 0.01, num=10)\n    p_list = [Particle(x=x, y=x, p=0, E=1) for x in x_coors]\n    P = [copy.deepcopy(p_list)]\n\n    navi = Navigator(lat3)\n    dz = 0.01\n\n    for _ in range(int(lat3.totalLen / dz)):\n        tracking_step(lat3, p_list, dz=dz, navi=navi)\n        P.append(copy.deepcopy(p_list))\n    fig, (ax_x, ax_y) = plot_API(lat3, figsize=(10,6), legend=False, add_extra_subplot=True)\n    fig.suptitle(f"Sector Magnet: Focusing  Effect: Angle = {angle:.1f}\xb0")\n\n    for i in range(len(p_list)):\n        s = [p[i].s for p in P]\n        x = [p[i].x for p in P]\n        y = [p[i].y for p in P]\n\n        ax_x.plot(s, x, "C0")\n        ax_y.plot(s, y, "C1")\n\n    ax_x.set_ylabel("X [m]")\n    ax_y.set_ylabel("Y [m]")\n    ax_x.grid(True)\n    ax_y.grid(True)\n\n    if save_path:\n        fig.savefig(save_path)\n        plt.close(fig)\n    else:\n        plt.show()\n\n# Create interactive sliders for the parameters\ninteract(\n    lambda angle: plot_sbend_focus(angle=angle, save_path=None),\n    angle=FloatSlider(min=-90, max=90, step=1, value=0),)\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"png",src:t(1889).A+"",width:"1000",height:"600"})}),"\n",(0,i.jsxs)(n.h3,{id:"rectangular-dipole-magnet-rbend",children:["Rectangular Dipole Magnet (",(0,i.jsx)(n.code,{children:"RBend"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"rectangular dipole"})," is simpler and more common in practice due to ease of manufacturing. Unlike the ",(0,i.jsx)(n.code,{children:"SBend"}),", in a rectangular dipole the entrance and exit faces are ",(0,i.jsx)(n.strong,{children:"perpendicular to the magnet body"}),", not to the beam trajectory. As a result, the beam enters and exits the magnet at an angle of ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"\u03d5"}),(0,i.jsx)(n.mi,{mathvariant:"normal",children:"/"}),(0,i.jsx)(n.mn,{children:"2"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\phi/2"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"\u03d5"}),(0,i.jsx)(n.span,{className:"mord",children:"/2"})]})})]})," with respect to the face of the magnet, where ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mi,{children:"\u03d5"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\phi"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"\u03d5"})]})})]})," is the total bending angle."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"RBend",src:t(1531).A+"",width:"514",height:"315"})}),"\n",(0,i.jsxs)(n.p,{children:["The animation below demonstrates how a beam behaves when passing through an ",(0,i.jsx)(n.code,{children:"RBend"}),", illustrating the distinct focusing effect caused by the non-normal incidence at the edges."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Assuming these come from your simulation code\n# from your_code import Drift, SBend, MagneticLattice, Navigator, Particle, tracking_step\n\n# Setup lattice (this stays outside the function)\nd = Drift(l=1)\nb = RBend(l=0.5, angle=5/180*np.pi)\ncell = [d, b, d]\nlat3 = MagneticLattice(cell)\n\ndef plot_rbend_focus(angle=0.01, save_path=None):\n    b.angle = angle * np.pi / 180\n    b.e1 = b.angle/2 # edge angle is not changing automatcally it has to be also set \n    b.e2 = b.angle/2 # edge angle is not changing automatcally it has to be also set \n    \n    x_coors = np.linspace(-0.01, 0.01, num=10)\n    p_list = [Particle(x=x, y=x, p=0, E=1) for x in x_coors]\n    P = [copy.deepcopy(p_list)]\n\n    navi = Navigator(lat3)\n    dz = 0.01\n\n    for _ in range(int(lat3.totalLen / dz)):\n        tracking_step(lat3, p_list, dz=dz, navi=navi)\n        P.append(copy.deepcopy(p_list))\n    \n    fig, (ax_x, ax_y) = plot_API(lat3, figsize=(10,6), legend=False, add_extra_subplot=True)\n    fig.suptitle(f"Rectangular Magnet: Focusing  Effect: Angle = {angle:.1f}\xb0")\n\n    for i in range(len(p_list)):\n        s = [p[i].s for p in P]\n        x = [p[i].x for p in P]\n        y = [p[i].y for p in P]\n\n        ax_x.plot(s, x, "C0")\n        ax_y.plot(s, y, "C1")\n\n    ax_x.set_ylabel("X [m]")\n    ax_y.set_ylabel("Y [m]")\n    ax_x.grid(True)\n    ax_y.grid(True)\n    #plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n\n    if save_path:\n        fig.savefig(save_path)\n        plt.close(fig)\n    else:\n        plt.show()\n\n# Create interactive sliders for the parameters\ninteract(\n    lambda angle: plot_rbend_focus(angle=angle, save_path=None),\n    angle=FloatSlider(min=-90, max=90, step=1, value=0),)\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"png",src:t(1544).A+"",width:"1000",height:"600"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},9765:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/dipole_disp-2acaf3af42af6152176bee229cdd6112.gif"},7174:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/quad_scan_beam-596325131565b436c691ea90cbf9dfcf.gif"},6144:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/quad_scan_betas-e974047be79e88ecc76d1e7eafb930e8.gif"},1544:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/rbend-daa655cc8cb78581e2996075e82fe682.gif"},1531:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/rbend-4051eb5b2d48c780b389ff47d20b427e.png"},1889:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/sbend-14f3ee86437fdf5d5639933aa9c2fa43.gif"},82:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/sbend-5f15e00360aa756e55928ec118cd365e.png"},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function l(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);