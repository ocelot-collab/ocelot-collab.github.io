"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[9867],{5469:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"docu/OCELOT fundamentals/tracking","title":"Tracking Functions","description":"track","source":"@site/docs/docu/OCELOT fundamentals/tracking.md","sourceDirName":"docu/OCELOT fundamentals","slug":"/docu/OCELOT fundamentals/tracking","permalink":"/docs/docu/OCELOT fundamentals/tracking","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot/docs/docu/OCELOT fundamentals/tracking.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Tracking Functions"},"sidebar":"docsSidebar","previous":{"title":"Navigator","permalink":"/docs/docu/OCELOT fundamentals/navigator"},"next":{"title":"ParticleArray","permalink":"/docs/docu/OCELOT fundamentals/particle-array"}}');var s=t(4848),i=t(8453);const c={sidebar_position:7,title:"Tracking Functions"},l="Tracking Functions",a={},d=[{value:"<code>track</code>",id:"track",level:2},{value:"Description:",id:"description",level:3},{value:"Arguments:",id:"arguments",level:3},{value:"Returns:",id:"returns",level:3},{value:"Notes:",id:"notes",level:3},{value:"<code>tracking_step</code>",id:"tracking_step",level:2},{value:"Description:",id:"description-1",level:3},{value:"Arguments:",id:"arguments-1",level:3},{value:"Returns:",id:"returns-1",level:3},{value:"Notes:",id:"notes-1",level:3},{value:"<code>lattice_track</code>",id:"lattice_track",level:2},{value:"Description:",id:"description-2",level:3},{value:"Arguments:",id:"arguments-2",level:3},{value:"Returns:",id:"returns-2",level:3},{value:"Notes:",id:"notes-2",level:3}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tracking-functions",children:"Tracking Functions"})}),"\n",(0,s.jsx)(n.h2,{id:"track",children:(0,s.jsx)(n.code,{children:"track"})}),"\n",(0,s.jsx)(n.h3,{id:"description",children:"Description:"}),"\n",(0,s.jsx)(n.p,{children:"Tracks particles through a lattice and optionally calculates Twiss parameters during the tracking. The method applies the relevant physical processes at each step and returns the updated particle array along with calculated Twiss parameters."}),"\n",(0,s.jsx)(n.p,{children:"Code of the function is presented here."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def track(lattice, p_array, navi=None, print_progress=True, calc_tws=True, \n          bounds=None, return_df=False,\n          overwrite_progress=True) -> Tuple[Union[List[Twiss], pd.DataFrame], ParticleArray]:\n    ...\n    for t_maps, dz, proc_list, phys_steps in navi.get_next_step():\n        for tm in t_maps:\n            tm.apply(p_array)\n            ...\n        ...\n        for p, z_step in zip(proc_list, phys_steps):\n            ...\n            p.apply(p_array, z_step)\n            ...\n    ...\n    # finalize PhysProcesses\n    for p in navi.get_phys_procs():\n        p.finalize()\n    ...\n    return tws_track, p_array\n"})}),"\n",(0,s.jsx)(n.h3,{id:"arguments",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"lattice"})," ",(0,s.jsx)(n.a,{href:"/docs/docu/OCELOT%20fundamentals/magnet-lattice",children:(0,s.jsx)(n.code,{children:"MagneticLattice"})}),": The magnetic lattice through which the particles will be tracked."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"p_array"})," (",(0,s.jsx)(n.code,{children:"ParticleArray"}),"): The array of particles to be tracked."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"navi"})," (",(0,s.jsx)(n.code,{children:"Navigator"}),", optional): The navigator for tracking. If ",(0,s.jsx)(n.code,{children:"None"}),", a default navigator is used with no physical processes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"print_progress"})," (",(0,s.jsx)(n.code,{children:"bool"}),", optional): If ",(0,s.jsx)(n.code,{children:"True"}),", the progress of the tracking is printed. Default is ",(0,s.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"calc_tws"})," (",(0,s.jsx)(n.code,{children:"bool"}),", optional): If ",(0,s.jsx)(n.code,{children:"True"}),", Twiss parameters are calculated during the tracking. Default is ",(0,s.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"bounds"})," (",(0,s.jsx)(n.code,{children:"list"}),", optional): Optional bounds for the tracking based on the standard deviation of ",(0,s.jsx)(n.code,{children:"p_array.tau()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"return_df"})," (",(0,s.jsx)(n.code,{children:"bool"}),", optional): If ",(0,s.jsx)(n.code,{children:"True"}),", the output is returned as a pandas DataFrame. Default is ",(0,s.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"overwrite_progress"})," (",(0,s.jsx)(n.code,{children:"bool"}),", optional): If ",(0,s.jsx)(n.code,{children:"True"}),", the progress message will overwrite the previous message in the console. Default is ",(0,s.jsx)(n.code,{children:"True"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"returns",children:"Returns:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Twiss list or pandas DataFrame"}),": If ",(0,s.jsx)(n.code,{children:"calc_tws"})," is ",(0,s.jsx)(n.code,{children:"True"}),", a list of Twiss parameters is returned. If ",(0,s.jsx)(n.code,{children:"return_df"})," is ",(0,s.jsx)(n.code,{children:"True"}),", the result is returned as a pandas DataFrame."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ParticleArray"}),": The updated array of particles after the tracking."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"notes",children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applies all physics processes at each step."}),"\n",(0,s.jsx)(n.li,{children:"Optionally prints tracking progress, including the current position in the lattice and the applied processes."}),"\n",(0,s.jsx)(n.li,{children:"The method ends when the particle list is empty or the lattice length is exceeded."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tracking_step",children:(0,s.jsx)(n.code,{children:"tracking_step"})}),"\n",(0,s.jsx)(n.h3,{id:"description-1",children:"Description:"}),"\n",(0,s.jsxs)(n.p,{children:["Tracks particles for a fixed step ",(0,s.jsx)(n.code,{children:"dz"})," through a magnetic lattice and applies the relevant transfer maps to the particle list."]}),"\n",(0,s.jsx)(n.h3,{id:"arguments-1",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"lat"})," (",(0,s.jsx)(n.code,{children:"MagneticLattice"}),"): The magnetic lattice through which the particles will be tracked."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"particle_list"})," (",(0,s.jsx)(n.code,{children:"ParticleArray"})," or ",(0,s.jsx)(n.code,{children:"Particle"})," list): The list of particles to be tracked."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"dz"})," (",(0,s.jsx)(n.code,{children:"float"}),"): The step size in meters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"navi"})," (",(0,s.jsx)(n.code,{children:"Navigator"}),"): The navigator instance controlling the tracking."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"returns-1",children:"Returns:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"None"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"notes-1",children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Checks that the lattice in the ",(0,s.jsx)(n.code,{children:"Navigator"})," matches the lattice passed in the ",(0,s.jsx)(n.code,{children:"tracking_step"})," function."]}),"\n",(0,s.jsx)(n.li,{children:"The transfer maps for the step are retrieved and applied to the particles."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lattice_track",children:(0,s.jsx)(n.code,{children:"lattice_track"})}),"\n",(0,s.jsx)(n.h3,{id:"description-2",children:"Description:"}),"\n",(0,s.jsx)(n.p,{children:"Tracks a particle through the entire lattice and saves the particle's state after each element."}),"\n",(0,s.jsx)(n.h3,{id:"arguments-2",children:"Arguments:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"lat"})," (",(0,s.jsx)(n.code,{children:"MagneticLattice"}),"): The magnetic lattice through which the particle will be tracked."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"p"})," (",(0,s.jsx)(n.code,{children:"Particle"}),"): The particle to be tracked."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"returns-2",children:"Returns:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A list of ",(0,s.jsx)(n.code,{children:"Particle"})," instances, each representing the state of the particle after each element in the lattice."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"notes-2",children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creates a copy of the particle at each element in the lattice."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function c(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);