"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[8550],{8017:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>s});const n=JSON.parse('{"id":"tutorial/tutorial-beam-dynamics/CSR","title":"5. Coherent Synchrotron Radiation","description":"This notebook was created by Sergey Tomin (sergey.tomin@desy.de). January 2018.","source":"@site/docs/tutorial/tutorial-beam-dynamics/5_CSR.md","sourceDirName":"tutorial/tutorial-beam-dynamics","slug":"/tutorial/tutorial-beam-dynamics/CSR","permalink":"/docs/tutorial/tutorial-beam-dynamics/CSR","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/tutorial/tutorial-beam-dynamics/5_CSR.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"5. Coherent Synchrotron Radiation"},"sidebar":"tutorialSidebar","previous":{"title":"4. Wakefields","permalink":"/docs/tutorial/tutorial-beam-dynamics/wake"},"next":{"title":"6. Coupler Kick","permalink":"/docs/tutorial/tutorial-beam-dynamics/coupler_kick"}}');var r=a(4848),i=a(8453);const l={sidebar_position:5,title:"5. Coherent Synchrotron Radiation"},c="5. Coherent Synchrotron Radiation",o={},s=[{value:"This example will cover the following topics:",id:"this-example-will-cover-the-following-topics",level:4},{value:"Requirements",id:"requirements",level:4},{value:"Load beam distribution from CSRtrack format",id:"load-beam-distribution-from-csrtrack-format",level:3},{value:"create BC2 lattice",id:"create-bc2-lattice",level:3},{value:"Initialization tracking method and MagneticLattice object",id:"initialization-tracking-method-and-magneticlattice-object",level:4},{value:"Create CSR object",id:"create-csr-object",level:3},{value:"Track particles with and without CSR effect",id:"track-particles-with-and-without-csr-effect",level:3},{value:"display trajectory of the reference particle in CSR region",id:"display-trajectory-of-the-reference-particle-in-csr-region",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("small",{children:(0,r.jsxs)(t.p,{children:["This notebook was created by Sergey Tomin (",(0,r.jsx)(t.a,{href:"mailto:sergey.tomin@desy.de",children:"sergey.tomin@desy.de"}),"). January 2018."]})}),"\n",(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"5-coherent-synchrotron-radiation",children:"5. Coherent Synchrotron Radiation"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Second order tracking with CSR effect of the 200k particles."})}),"\n",(0,r.jsx)(t.p,{children:"As an example, we will use bunch compressor BC2 of the European XFEL Injector."}),"\n",(0,r.jsxs)(t.p,{children:["The CSR module uses a fast \u2018projected\u2019 1-D method from CSRtrack code and follows the approach presented in ",(0,r.jsx)(t.a,{href:"http://www.sciencedirect.com/science/article/pii/S0168900298006238",children:"Saldin et al 1998"}),", ",(0,r.jsx)(t.a,{href:"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.233.564&rep=rep1&type=pdf",children:"Dohlus 2003"}),", ",(0,r.jsx)(t.a,{href:"https://accelconf.web.cern.ch/accelconf/f04/papers/MOCOS05/MOCOS05.PDF",children:"Dohlus 2004"}),".\nThe particle tracking uses matrices up to the second order. CSR wake is calculated continuously through beam lines of arbitrary flat geometry.\nThe transverse self-forces are neglected completely. The method calculates the longitudinal self-field of a one-dimensional beam that is obtained by a projection of the \u2018real\u2019 three-dimensional beam onto a reference trajectory.\nA smooth one-dimensional charge density is calculated by binning and filtering, which is crucial for the stability and accuracy of the simulation, since the instability is sensitive to high frequency components in the charge density."]}),"\n",(0,r.jsx)(t.h4,{id:"this-example-will-cover-the-following-topics",children:"This example will cover the following topics:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Initialization of the CSR object and the places of it applying"}),"\n",(0,r.jsx)(t.li,{children:"tracking of second order with CSR effect."}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"requirements",children:"Requirements"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"in.fmt1    - input file, initial beam distribution in CSRtrack format (was obtained from s2e simulation performed with ASTRA/CSRtrack)."}),"\n",(0,r.jsx)(t.li,{children:"out.fmt1 - output file, beam distribution after BC2 bunch compressor (was obtained with CSRtrack)"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'import sys\nsys.path.append("/Users/tomins/Nextcloud/DESY/repository/ocelot")\n# the output of plotting commands is displayed inline within frontends, \n# directly below the code cell that produced it\nfrom time import time \n\n# this python library provides generic shallow (copy) and deep copy (deepcopy) operations \nfrom copy import deepcopy\n\n# import from Ocelot main modules and functions\nfrom ocelot import *\n\n# import from Ocelot graphical modules\nfrom ocelot.gui.accelerator import *\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"    initializing ocelot...\n"})}),"\n",(0,r.jsx)(t.h3,{id:"load-beam-distribution-from-csrtrack-format",children:"Load beam distribution from CSRtrack format"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'# load and convert CSRtrack file to OCELOT beam distribution\n# p_array_i = csrtrackBeam2particleArray("in.fmt1", orient="H")\n\n# save ParticleArray to compresssed numpy array \n# save_particle_array("test.npz", p_array_i)\np_array_i = load_particle_array("csr_beam.npz")\n\n# show the longitudinal phase space\nplt.plot(-p_array_i.tau()*1000, p_array_i.p(), "r.")\nplt.xlabel("S, mm")\nplt.ylabel("dE/pc")\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"png",src:a(5593).A+"",width:"596",height:"432"})}),"\n",(0,r.jsx)(t.h3,{id:"create-bc2-lattice",children:"create BC2 lattice"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"b1 = Bend(l = 0.5001, angle=-0.0336, e1=0.0, e2=-0.0336, gap=0, tilt=0, eid='BB.393.B2')\nb2 = Bend(l = 0.5001, angle=0.0336, e1=0.0336, e2=0.0, gap=0,  tilt=0, eid='BB.402.B2')\nb3 = Bend(l = 0.5001, angle=0.0336, e1=0.0, e2=0.0336, gap=0, tilt=0,  eid='BB.404.B2')\nb4 = Bend(l = 0.5001, angle=-0.0336, e1=-0.0336, e2=0.0, gap=0,  tilt=0, eid='BB.413.B2')\n\nd_slope = Drift(l=8.5/np.cos(b2.angle))\n\nstart_csr = Marker()\nstop_csr = Marker()\n\n# define cell frome the bends and drifts\ncell = [start_csr, Drift(l=0.1), b1 , d_slope  , b2, Drift(l=1.5), \n        b3, d_slope, Marker(), b4, Drift(l= 1.), stop_csr]\n"})}),"\n",(0,r.jsx)(t.h4,{id:"initialization-tracking-method-and-magneticlattice-object",children:"Initialization tracking method and MagneticLattice object"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'# for second order tracking we have to choose SecondTM \nmethod = {"global": SecondTM}\n\n# for first order tracking uncomment next line\n# method = {"global": TransferMap}\n\nlat = MagneticLattice(cell, method=method)\n'})}),"\n",(0,r.jsx)(t.h3,{id:"create-csr-object",children:"Create CSR object"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"csr = CSR(n_bin=300, m_bin=5, sigma_min=.2e-6)\n"})}),"\n",(0,r.jsx)(t.h3,{id:"track-particles-with-and-without-csr-effect",children:"Track particles with and without CSR effect"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'navi = Navigator(lat)\n\n# track witout CSR effect \np_array_no = deepcopy(p_array_i)\nprint("\\n tracking without CSR effect .... ")\nstart = time()\ntws_no, p_array_no = track(lat, p_array_no, navi)\nprint("\\n time exec:", time() - start, "sec")\n\n# again create Navigator with needed step in [m]\nnavi = Navigator(lat)\nnavi.unit_step = 0.5 # m\n\n# add csr process to navigator with start and stop elements\nnavi.add_physics_proc(csr, start_csr, lat.sequence[-1])\n\n# tracking \nstart = time()\np_array_csr = deepcopy(p_array_i)\nprint("\\n tracking with CSR effect .... ")\ntws_csr, p_array_csr = track(lat, p_array_csr, navi)\nprint("\\n time exec:", time() - start, "sec")\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"     tracking without CSR effect .... \n    z = 21.610000676107052 / 21.610000676107052. Applied: \n     time exec: 0.5144369602203369 sec\n    \n     tracking with CSR effect .... \n    z = 21.610000676107052 / 21.610000676107052. Applied: CSR\n     time exec: 13.474658012390137 sec\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'# recalculate reference particle \nfrom ocelot.cpbd.beam import *\n\nrecalculate_ref_particle(p_array_csr)\nrecalculate_ref_particle(p_array_no)\n\n# load and convert CSRtrack file to OCELOT beam distribution \n# distribution after BC2\n# p_array_out = csrtrackBeam2particleArray("out.fmt1", orient="H")\n# save ParticleArray to compresssed numpy array \n# save_particle_array("scr_track.npz", p_array_out)\np_array_out = load_particle_array("scr_track.npz")\n\n# standard matplotlib functions \n\nplt.figure(2, figsize=(10, 6))\nplt.subplot(121)\nplt.plot(p_array_no.tau()*1000, p_array_no.p(), \'g.\', label="OCELOT no CSR")\nplt.plot(p_array_csr.tau()*1000, p_array_csr.p(), \'r.\', label="OCELOT CSR")\nplt.plot(p_array_out.tau()*1000, p_array_out.p(), \'b.\', label="CSRtrack")\nplt.legend(loc=3)\nplt.xlabel("s, mm")\nplt.ylabel("dE/pc")\nplt.grid(True)\n\n\nplt.subplot(122)\nplt.plot(p_array_no.tau()*1000, p_array_no.p(), \'g.\', label="Ocelot no CSR")\nplt.plot(p_array_out.tau()*1000, p_array_out.p(), \'b.\', label="CSRtrack")\nplt.plot(p_array_csr.tau()*1000, p_array_csr.p(), \'r.\', label="OCELOT CSR")\nplt.legend(loc=3)\nplt.xlabel("s, mm")\nplt.ylabel("dE/pc")\nplt.grid(True)\nplt.savefig("arcline_traj.png")\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"png",src:a(5860).A+"",width:"875",height:"530"})}),"\n",(0,r.jsx)(t.h3,{id:"display-trajectory-of-the-reference-particle-in-csr-region",children:"display trajectory of the reference particle in CSR region"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'fig = plt.figure(figsize=(10, 8))\nax1 = plt.subplot(211)\n# ax1.plot(self.csr_traj[0, :], self.csr_traj[0, :] -self.csr_traj[3, :], "r", label="X")\nax1.plot(csr.csr_traj[0, :], csr.csr_traj[1, :] * 1000, "r", label="X")\nax1.plot(csr.csr_traj[0, :], csr.csr_traj[2, :] * 1000, "b", label="Y")\nplt.legend()\nplt.ylabel("X/Y [mm]")\nplt.setp(ax1.get_xticklabels(), visible=False)\nax3 = plt.subplot(212, sharex=ax1)\nax3.plot(csr.csr_traj[0, :], csr.csr_traj[1 + 3, :] * 1000, "r", label=r"$X\'$")\nax3.plot(csr.csr_traj[0, :], csr.csr_traj[2 + 3, :] * 1000, "b", label=r"$Y\'$")\nplt.legend()\nplt.ylabel(r"$X\'/Y\'$ [mrad]")\nplt.xlabel("s [m]")\nplt.show()\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"png",src:a(2630).A+"",width:"856",height:"679"})})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},5860:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/5_CSR_13_0-ace0dee2ae8a3e42901d298125b49eb2.png"},2630:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/5_CSR_15_0-e1f08eccdbf406e36dd93c4376aeb2c3.png"},5593:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/5_CSR_4_1-8a3df4af03f7178de61595f6d557f062.png"},8453:(e,t,a)=>{a.d(t,{R:()=>l,x:()=>c});var n=a(6540);const r={},i=n.createContext(r);function l(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);