"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[4360],{6476:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"docu/trasfer-maps/second-order","title":"Second Order Map","description":"Second Order Map","source":"@site/docs/docu/trasfer-maps/second-order.md","sourceDirName":"docu/trasfer-maps","slug":"/docu/trasfer-maps/second-order","permalink":"/docs/docu/trasfer-maps/second-order","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/trasfer-maps/second-order.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Second Order Map","description":"Second Order Map"},"sidebar":"docsSidebar","previous":{"title":"First Order Map","permalink":"/docs/docu/trasfer-maps/first-order"},"next":{"title":"Physics Processes","permalink":"/docs/category/physics-processes"}}');var t=s(4848),l=s(8453);const a={sidebar_position:3,title:"Second Order Map",description:"Second Order Map"},i="SecondTM Class",c={},d=[{value:"Description",id:"description",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Constructor",id:"constructor",level:2},{value:"<code>__init__(self, create_tm_param_func, delta_e_func, tm_type: TMTypes, length: float, delta_length: float = 0.0)</code>",id:"__init__self-create_tm_param_func-delta_e_func-tm_type-tmtypes-length-float-delta_length-float--00",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Class Methods",id:"class-methods",level:2},{value:"<code>from_element(cls, element: Element, tm_type: TMTypes = TMTypes.MAIN, delta_l=None, **params)</code>",id:"from_elementcls-element-element-tm_type-tmtypes--tmtypesmain-delta_lnone-params",level:4},{value:"Instance Methods",id:"instance-methods",level:2},{value:"<code>t_apply(self, energy, X, U5666=0.0) -&gt; np.ndarray</code>",id:"t_applyself-energy-x-u566600---npndarray",level:4},{value:"<code>map_function(self, X, energy: float) -&gt; np.ndarray</code>",id:"map_functionself-x-energy-float---npndarray",level:4},{value:"<code>calculate_Tb(self, energy) -&gt; np.ndarray</code>",id:"calculate_tbself-energy---npndarray",level:4}];function o(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",hr:"hr",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsxs)(n.h1,{id:"secondtm-class",children:[(0,t.jsx)(n.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/transformations/second_order.py",children:"SecondTM"})," Class"]})}),"\n",(0,t.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SecondTM"})," class extends the ",(0,t.jsx)(n.a,{href:"/docs/docu/trasfer-maps/transormation",children:(0,t.jsx)(n.code,{children:"Transformation"})})," base class to implement a ",(0,t.jsx)(n.strong,{children:"second-order"})," transformation.\nIt handles both main and edge transformations for elements, assuming the element has implemented the corresponding\nmethods to generate second-order parameters. This transformation can apply second-order terms to the particle coordinates,\nbeyond the linear behavior modeled by a first-order transformation."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inherits"}),": ",(0,t.jsx)(n.code,{children:"Transformation"})]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,t.jsx)(n.h4,{id:"__init__self-create_tm_param_func-delta_e_func-tm_type-tmtypes-length-float-delta_length-float--00",children:(0,t.jsx)(n.code,{children:"__init__(self, create_tm_param_func, delta_e_func, tm_type: TMTypes, length: float, delta_length: float = 0.0)"})}),"\n",(0,t.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"create_tm_param_func"}),": A callback function that generates the second-order transformation parameters (including rotation matrix ",(0,t.jsx)(n.code,{children:"R"}),", second-order tensor ",(0,t.jsx)(n.code,{children:"T"}),", translation vector ",(0,t.jsx)(n.code,{children:"B"}),", etc.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"delta_e_func"}),": A callback function for calculating the energy change (",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{mathvariant:"normal",children:"\u0394"}),(0,t.jsx)(n.mi,{children:"E"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\Delta E"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(n.span,{className:"mord",children:"\u0394"}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"})]})})]}),"), if applicable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"tm_type"})," (",(0,t.jsx)(n.code,{children:"TMTypes"}),"): The type of transformation (",(0,t.jsx)(n.code,{children:"MAIN"}),", ",(0,t.jsx)(n.code,{children:"ENTRANCE"}),", ",(0,t.jsx)(n.code,{children:"EXIT"}),", etc.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"length"})," (",(0,t.jsx)(n.code,{children:"float"}),"): The full length of the element (for main transformations)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"delta_length"})," (",(0,t.jsx)(n.code,{children:"float"}),", optional): Defines a subset length of the element if only a portion is considered. Defaults to ",(0,t.jsx)(n.code,{children:"0.0"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Behavior"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Initializes a second-order multiplication method (",(0,t.jsx)(n.code,{children:"SecondOrderMult().tmat_multip"}),") for matrix operations."]}),"\n",(0,t.jsxs)(n.li,{children:["Calls the parent constructor (",(0,t.jsx)(n.code,{children:"Transformation"}),") to set up the transformation."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"class-methods",children:"Class Methods"}),"\n",(0,t.jsx)(n.h4,{id:"from_elementcls-element-element-tm_type-tmtypes--tmtypesmain-delta_lnone-params",children:(0,t.jsx)(n.code,{children:"from_element(cls, element: Element, tm_type: TMTypes = TMTypes.MAIN, delta_l=None, **params)"})}),"\n",(0,t.jsxs)(n.p,{children:["Creates a ",(0,t.jsx)(n.code,{children:"SecondTM"})," transformation from a ",(0,t.jsx)(n.code,{children:"MagneticLattice"})," element. This method calls ",(0,t.jsx)(n.code,{children:"cls.create"})," with:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Functions for entrance, main, and exit second-order parameter generation (if the element supports edges)."}),"\n",(0,t.jsxs)(n.li,{children:["A function for calculating ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{mathvariant:"normal",children:"\u0394"}),(0,t.jsx)(n.mi,{children:"E"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\Delta E"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(n.span,{className:"mord",children:"\u0394"}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"})]})})]}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The element's length (",(0,t.jsx)(n.code,{children:"element.l"}),") and an optional partial length ",(0,t.jsx)(n.code,{children:"delta_l"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"element"})," (",(0,t.jsx)(n.code,{children:"Element"}),"): The beamline element for which to create the second-order transformation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"tm_type"})," (",(0,t.jsx)(n.code,{children:"TMTypes"}),"): The transformation type (",(0,t.jsx)(n.code,{children:"ENTRANCE"}),", ",(0,t.jsx)(n.code,{children:"MAIN"}),", or ",(0,t.jsx)(n.code,{children:"EXIT"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"delta_l"})," (",(0,t.jsx)(n.code,{children:"float"}),", optional): A partial length of the element, if needed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"params"}),": Additional keyword arguments."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"SecondTM"})," instance configured with the element's parameter-generating functions."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,t.jsx)(n.h4,{id:"t_applyself-energy-x-u566600---npndarray",children:(0,t.jsx)(n.code,{children:"t_apply(self, energy, X, U5666=0.0) -> np.ndarray"})}),"\n",(0,t.jsxs)(n.p,{children:["Applies the second-order transformation to the phase-space coordinates in ",(0,t.jsx)(n.code,{children:"X"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"energy"})," (",(0,t.jsx)(n.code,{children:"float"}),"): The beam energy in GeV."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"X"})," (",(0,t.jsx)(n.code,{children:"np.ndarray"}),"): A ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mn,{children:"6"}),(0,t.jsx)(n.mo,{children:"\xd7"}),(0,t.jsx)(n.mi,{children:"N"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"6 \\times N"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(n.span,{className:"mord",children:"6"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})]})]})," array representing the particle coordinates (",(0,t.jsx)(n.code,{children:"x"}),", ",(0,t.jsx)(n.code,{children:"px"}),", ",(0,t.jsx)(n.code,{children:"y"}),", ",(0,t.jsx)(n.code,{children:"py"}),", ",(0,t.jsx)(n.code,{children:"tau"}),", ",(0,t.jsx)(n.code,{children:"p"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"U5666"})," (",(0,t.jsx)(n.code,{children:"float"}),", optional): An additional parameter (if needed) for higher-order corrections; defaults to 0.0."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Updated coordinates in ",(0,t.jsx)(n.code,{children:"X"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Retrieves the transformation parameters (",(0,t.jsx)(n.code,{children:"R"}),", ",(0,t.jsx)(n.code,{children:"T"}),", ",(0,t.jsx)(n.code,{children:"B"}),", optional tilt)."]}),"\n",(0,t.jsxs)(n.li,{children:["Applies the second-order multiplication function ",(0,t.jsx)(n.code,{children:"self.multiplication(X, R, T)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Adds the translation vector ",(0,t.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Returns the updated ",(0,t.jsx)(n.code,{children:"X"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"map_functionself-x-energy-float---npndarray",children:(0,t.jsx)(n.code,{children:"map_function(self, X, energy: float) -> np.ndarray"})}),"\n",(0,t.jsxs)(n.p,{children:["Implements the transformation by calling ",(0,t.jsx)(n.code,{children:"t_apply"})," on the given coordinates ",(0,t.jsx)(n.code,{children:"X"})," at the specified ",(0,t.jsx)(n.code,{children:"energy"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"X"})," (",(0,t.jsx)(n.code,{children:"np.ndarray"}),"): The particle coordinates."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"energy"})," (",(0,t.jsx)(n.code,{children:"float"}),"): The beam energy."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The transformed particle coordinates."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"calculate_tbself-energy---npndarray",children:(0,t.jsx)(n.code,{children:"calculate_Tb(self, energy) -> np.ndarray"})}),"\n",(0,t.jsx)(n.p,{children:"A placeholder method indicating the calculation of a \u201cTb\u201d matrix, which could be necessary for certain advanced second-order calculations."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A NumPy array representing the ",(0,t.jsx)(n.code,{children:"Tb"})," matrix."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Raises ",(0,t.jsx)(n.code,{children:"NotImplementedError"})," by default, indicating this function is not yet fully implemented."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var r=s(6540);const t={},l=r.createContext(t);function a(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);