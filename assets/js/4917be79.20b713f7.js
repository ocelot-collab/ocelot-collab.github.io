"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[7597],{5751:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"docu/OCELOT fundamentals/magnet-lattice","title":"MagneticLattice","description":"MagneticLattice class","source":"@site/docs/docu/OCELOT fundamentals/magnet-lattice.md","sourceDirName":"docu/OCELOT fundamentals","slug":"/docu/OCELOT fundamentals/magnet-lattice","permalink":"/docs/docu/OCELOT fundamentals/magnet-lattice","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/OCELOT fundamentals/magnet-lattice.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"MagneticLattice","description":"MagneticLattice class"},"sidebar":"docsSidebar","previous":{"title":"Ocelot Coordinate System","permalink":"/docs/docu/OCELOT fundamentals/coordinate_system"},"next":{"title":"Navigator","permalink":"/docs/docu/OCELOT fundamentals/navigator"}}');var l=n(4848),i=n(8453);const r={sidebar_position:5,title:"MagneticLattice",description:"MagneticLattice class"},a="MagneticLattice Class",c={},d=[{value:"Description",id:"description",level:2},{value:"Simplest Example of Use",id:"simplest-example-of-use",level:3},{value:"Constructor",id:"constructor",level:2},{value:"Arguments:",id:"arguments",level:4},{value:"Methods",id:"methods",level:2},{value:"<code>get_sequence_part(self, start: E, stop: E)</code>",id:"get_sequence_partself-start-e-stop-e",level:3},{value:"Arguments:",id:"arguments-1",level:4},{value:"Returns:",id:"returns",level:4},{value:"<code>update_transfer_maps(self)</code>",id:"update_transfer_mapsself",level:3},{value:"Returns:",id:"returns-1",level:4},{value:"<code>__str__(self)</code>",id:"__str__self",level:3},{value:"Returns:",id:"returns-2",level:4},{value:"<code>find_indices(self, element)</code>",id:"find_indicesself-element",level:3},{value:"Arguments:",id:"arguments-2",level:4},{value:"Returns:",id:"returns-3",level:4},{value:"<code>find_drifts(self)</code>",id:"find_driftsself",level:3},{value:"Returns:",id:"returns-4",level:4},{value:"<code>rem_drifts(self)</code>",id:"rem_driftsself",level:3},{value:"<code>save_as_py_file(self, file_name: str, tws0=None, remove_rep_drifts=True, power_supply=False)</code>",id:"save_as_py_fileself-file_name-str-tws0none-remove_rep_driftstrue-power_supplyfalse",level:3},{value:"Arguments:",id:"arguments-3",level:4},{value:"<code>transfer_maps(self, energy, output_at_each_step: bool = False, start: E = None, stop: E = None)</code>",id:"transfer_mapsself-energy-output_at_each_step-bool--false-start-e--none-stop-e--none",level:3},{value:"Arguments:",id:"arguments-4",level:4},{value:"Returns:",id:"returns-5",level:4},{value:"<code>survey(self, X0=0, Y0=0, Z0=0, theta0=0, phi0=0, psi0=0)</code>",id:"surveyself-x00-y00-z00-theta00-phi00-psi00",level:3},{value:"Arguments",id:"arguments-5",level:4},{value:"Returns",id:"returns-6",level:4},{value:"Notes",id:"notes",level:4},{value:"<code>print_sequence(self, start: E = None, stop: E = None)</code>",id:"print_sequenceself-start-e--none-stop-e--none",level:3},{value:"Arguments:",id:"arguments-6",level:4},{value:"Returns:",id:"returns-7",level:4},{value:"<code>periodic_twiss(self, tws=None)</code>",id:"periodic_twissself-twsnone",level:3},{value:"Arguments:",id:"arguments-7",level:4},{value:"Returns:",id:"returns-8",level:4}];function o(e){const s={a:"a",admonition:"admonition",annotation:"annotation",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",msub:"msub",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.header,{children:(0,l.jsxs)(s.h1,{id:"magneticlattice-class",children:[(0,l.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/magnetic_lattice.py#L163",children:"MagneticLattice"})," Class"]})}),"\n",(0,l.jsx)(s.h2,{id:"description",children:"Description"}),"\n",(0,l.jsxs)(s.p,{children:["The ",(0,l.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/magnetic_lattice.py#L163",children:(0,l.jsx)(s.code,{children:"MagneticLattice"})})," class\nrepresents a magnetic lattice, which is a sequence of elements forming a beamline. The lattice elements can include magnets,\nquadrupoles, undulators, and drifts, and they are used to model the trajectory and dynamics of a particle beam.\nThis class allows for various operations like updating transfer maps, calculating lattice length, and finding specific\nelements within the lattice. It also provides functionality for calculating transfer maps and periodic Twiss parameters."]}),"\n",(0,l.jsx)(s.h3,{id:"simplest-example-of-use",children:"Simplest Example of Use"}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-python",children:"from ocelot import *\n# Create elements of beamline\nd = Drift(l=1)\nq = Quadrupole(l=1, k1=1)\n\n# Create your beamline - sequence of elements\ncell = (d, q)\n\nlat = MagneticLattice(cell)\n"})}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{id:"constructor",children:"Constructor"}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-python",children:"class MagneticLattice:\n    def __init__(self, sequence, start: E = None, stop: E = None, method=None):\n        ...\n"})}),"\n",(0,l.jsx)(s.h4,{id:"arguments",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"sequence"})," (",(0,l.jsx)(s.code,{children:"list"}),"): A list of elements that form the lattice."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"start"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),", optional): The first element of the lattice. If ",(0,l.jsx)(s.code,{children:"None"}),", the lattice starts with the first element of the sequence."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"stop"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),", optional): The last element of the lattice (included). If ",(0,l.jsx)(s.code,{children:"None"}),", the lattice stops with the last element of the sequence."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"method"})," (",(0,l.jsx)(s.code,{children:"dict"}),", optional): A dictionary specifying the tracking method for the lattice. If no method is provided,\n",(0,l.jsx)(s.a,{href:"/docs/docu/trasfer-maps/first-order",children:(0,l.jsx)(s.code,{children:"TransferMap"})})," is used as the global default for all elements.\nSpecific methods for individual elements can also be set."]}),"\n",(0,l.jsx)(s.p,{children:"Example:"}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-python",children:'method = {"global": TransferMap} # default first order transfer map\nlat = MagneticLattice(cell, method=method)\n# or\nmethod = {"global": SecondTM, Octupole: KickTM, Undulator: RungeKuttaTM}\nlat = MagneticLattice(cell, method=method)\n'})}),"\n",(0,l.jsx)(s.p,{children:"In this example:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Sets ",(0,l.jsx)(s.a,{href:"/docs/docu/trasfer-maps/second-order",children:(0,l.jsx)(s.code,{children:"SecondTM"})})," (second order transfer maps) as the global transfer map for all elements."]}),"\n",(0,l.jsxs)(s.li,{children:["Assigns ",(0,l.jsx)(s.code,{children:"KickTM"})," specifically for ",(0,l.jsx)(s.code,{children:"Octupole"})," elements."]}),"\n",(0,l.jsxs)(s.li,{children:["Assigns ",(0,l.jsx)(s.code,{children:"RungeKuttaTM"})," specifically for ",(0,l.jsx)(s.code,{children:"Undulator"})," elements."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.admonition,{type:"info",children:[(0,l.jsxs)(s.p,{children:["In order to avoid mistakes, the ",(0,l.jsx)(s.strong,{children:"start"})," and ",(0,l.jsx)(s.strong,{children:"stop"})," element must be different objects.\nIt is also recommended to use the Marker element as both the ",(0,l.jsx)(s.strong,{children:"start"})," and ",(0,l.jsx)(s.strong,{children:"stop"})," element."]}),(0,l.jsx)(s.p,{children:"Example:"}),(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-python",children:'m1 = Marker()\nm2 = Marker()\ncell = [m1, d, q, ... , m2, d10, qf10, ...]\nlat = MagneticLattice(cell, start=m1, stop=m2, method={"global": SecondTM})\n'})})]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,l.jsx)(s.h3,{id:"get_sequence_partself-start-e-stop-e",children:(0,l.jsx)(s.code,{children:"get_sequence_part(self, start: E, stop: E)"})}),"\n",(0,l.jsxs)(s.p,{children:["This method gets a part of the lattice sequence starting from ",(0,l.jsx)(s.code,{children:"start"})," to ",(0,l.jsx)(s.code,{children:"stop"}),"."]}),"\n",(0,l.jsx)(s.h4,{id:"arguments-1",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"start"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),"): The element where the sequence starts."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"stop"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),"): The element where the sequence ends (included ",(0,l.jsx)(s.strong,{children:"stop"})," element)."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A sublist of elements from the sequence."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"update_transfer_mapsself",children:(0,l.jsx)(s.code,{children:"update_transfer_maps(self)"})}),"\n",(0,l.jsxs)(s.p,{children:["The name of the method does not accurately reflect its functionality but is retained for legacy purposes.\nThis method assigns specific transfer maps to each element in the sequence based on a ",(0,l.jsx)(s.code,{children:"method"})," dictionary.\nAdditionally, it calculates the total length ",(0,l.jsx)(s.code,{children:"self.totalLen"})," of the lattice by summing the lengths of its elements."]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-python",children:"for i, element in enumerate(self.sequence):\n    self.totalLen += element.l  # Accumulate the total length of the lattice\n    tm_class_type = self.method.get(element.__class__)  # Get specific transfer map for element class\n    if tm_class_type:\n        element.set_tm(tm_class_type)  # Set the class-specific transfer map\n    else:\n        tm_class_type = self.method.get('global')  # Fallback to the global transfer map\n        if tm_class_type:\n            element.set_tm(tm_class_type)  # Set the global transfer map\n"})}),"\n",(0,l.jsx)(s.h4,{id:"returns-1",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["The updated ",(0,l.jsx)(s.code,{children:"MagneticLattice"})," object."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"__str__self",children:(0,l.jsx)(s.code,{children:"__str__(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Returns a string representation of the lattice, showing the total length and details of each element."}),"\n",(0,l.jsx)(s.h4,{id:"returns-2",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A string containing the total length and details of each element in the sequence."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"find_indicesself-element",children:(0,l.jsx)(s.code,{children:"find_indices(self, element)"})}),"\n",(0,l.jsx)(s.p,{children:"Finds the indices of elements in the sequence by their class type."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-2",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"element"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),"): The class type of the element to search for."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-3",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A list of indices where the specified element type is found in the sequence."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"find_driftsself",children:(0,l.jsx)(s.code,{children:"find_drifts(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Finds the drift elements in the sequence and returns them."}),"\n",(0,l.jsx)(s.h4,{id:"returns-4",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A list of drift elements."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"rem_driftsself",children:(0,l.jsx)(s.code,{children:"rem_drifts(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Removes repeated drift elements from the lattice."}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"save_as_py_fileself-file_name-str-tws0none-remove_rep_driftstrue-power_supplyfalse",children:(0,l.jsx)(s.code,{children:"save_as_py_file(self, file_name: str, tws0=None, remove_rep_drifts=True, power_supply=False)"})}),"\n",(0,l.jsx)(s.p,{children:"Saves the lattice to a Python file."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-3",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"file_name"})," (",(0,l.jsx)(s.code,{children:"str"}),"): The path and name of the Python file where the lattice will be stored."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"tws0"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,l.jsx)(s.code,{children:"Twiss"})}),", optional): A ",(0,l.jsx)(s.code,{children:"Twiss"})," object. If provided, the Twiss parameters will be printed at the beginning of the lattice file."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"remove_rep_drifts"})," (",(0,l.jsx)(s.code,{children:"bool"}),", optional): If ",(0,l.jsx)(s.code,{children:"True"}),", removes repeated drift elements from the lattice."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"power_supply"})," (",(0,l.jsx)(s.code,{children:"bool"}),", optional): If ",(0,l.jsx)(s.code,{children:"True"}),", writes the power supply IDs into the file."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"transfer_mapsself-energy-output_at_each_step-bool--false-start-e--none-stop-e--none",children:(0,l.jsx)(s.code,{children:"transfer_maps(self, energy, output_at_each_step: bool = False, start: E = None, stop: E = None)"})}),"\n",(0,l.jsx)(s.p,{children:"Calculates the transfer maps (first and second orders) for the entire lattice."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-4",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"energy"})," (",(0,l.jsx)(s.code,{children:"float"}),"): The initial electron beam energy in GeV."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"output_at_each_step"})," (",(0,l.jsx)(s.code,{children:"bool"}),", optional): If ",(0,l.jsx)(s.code,{children:"True"}),", returns the transfer maps at each step in the lattice."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"start"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),", optional): The element to start from in the sequence."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"stop"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),", optional): The element to stop at in the sequence."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-5",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["The transfer maps (",(0,l.jsx)(s.code,{children:"B"}),", ",(0,l.jsx)(s.code,{children:"R"}),", ",(0,l.jsx)(s.code,{children:"T"}),") for the entire lattice or at each step if ",(0,l.jsx)(s.code,{children:"output_at_each_step"})," is ",(0,l.jsx)(s.code,{children:"True"}),"."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"surveyself-x00-y00-z00-theta00-phi00-psi00",children:(0,l.jsx)(s.code,{children:"survey(self, X0=0, Y0=0, Z0=0, theta0=0, phi0=0, psi0=0)"})}),"\n",(0,l.jsxs)(s.p,{children:["Performs a ",(0,l.jsx)(s.strong,{children:"3D geometric survey"})," of the reference trajectory using a recursive\nvector/matrix formalism consistent with ",(0,l.jsx)(s.strong,{children:"MAD-8 survey conventions"}),"."]}),"\n",(0,l.jsxs)(s.p,{children:["The survey computes the global ",(0,l.jsx)(s.strong,{children:"positions and orientations"})," of the beamline\nalong the reference trajectory, taking into account element length, bending,\nand tilt."]}),"\n",(0,l.jsxs)(s.p,{children:["See also ",(0,l.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/survey",children:(0,l.jsx)(s.code,{children:"MachineLayout"})})," class"]}),"\n",(0,l.jsx)(s.h4,{id:"arguments-5",children:"Arguments"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"X0"})," (",(0,l.jsx)(s.code,{children:"float"}),", optional)",(0,l.jsx)(s.br,{}),"\n","Initial global X coordinate [m]."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"Y0"})," (",(0,l.jsx)(s.code,{children:"float"}),", optional)",(0,l.jsx)(s.br,{}),"\n","Initial global Y coordinate [m]."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"Z0"})," (",(0,l.jsx)(s.code,{children:"float"}),", optional)",(0,l.jsx)(s.br,{}),"\n","Initial global Z coordinate [m]."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"theta0"})," (",(0,l.jsx)(s.code,{children:"float"}),", optional)",(0,l.jsx)(s.br,{}),"\n","Initial azimuth angle [rad]."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"phi0"})," (",(0,l.jsx)(s.code,{children:"float"}),", optional)",(0,l.jsx)(s.br,{}),"\n","Initial elevation angle [rad]."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:"psi0"})," (",(0,l.jsx)(s.code,{children:"float"}),", optional)",(0,l.jsx)(s.br,{}),"\n","Initial roll angle around the local s-axis [rad]."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-6",children:"Returns"}),"\n",(0,l.jsxs)(s.p,{children:["The function returns ",(0,l.jsx)(s.strong,{children:"two lists of dictionaries"}),":"]}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"mid_survey_data"})}),(0,l.jsx)(s.br,{}),"\n","Survey data evaluated at the geometric center of each element.",(0,l.jsx)(s.br,{}),"\n","Intended mainly for inspection, tables, and diagnostics."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"end_survey_data"})}),(0,l.jsx)(s.br,{}),"\n","Survey data evaluated at the exit of each element.",(0,l.jsx)(s.br,{}),"\n","Intended for plotting, connectivity, and layout construction."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Each dictionary contains, among others, the following fields:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"r_start"})})," \u2014 global position at the element entrance"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"r_end"})})," \u2014 global position at the element exit"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"W_start"})})," \u2014 rotation matrix at the element entrance"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"W"})})," \u2014 rotation matrix at the survey record location"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"X, Y, Z"})})," \u2014 scalar global coordinates (convenience)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"XPD, YPD, ZPD"})})," \u2014 direction cosines of the local s-axis"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"element"})})," \u2014 reference to the corresponding lattice element"]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"notes",children:"Notes"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:["The rotation matrix ",(0,l.jsx)(s.code,{children:"W"})," maps vectors from the local element frame ",(0,l.jsx)(s.code,{children:"(x, y, s)"}),"\nto the global laboratory frame ",(0,l.jsx)(s.code,{children:"(X, Y, Z)"}),": ",(0,l.jsxs)(s.span,{className:"katex",children:[(0,l.jsx)(s.span,{className:"katex-mathml",children:(0,l.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,l.jsxs)(s.semantics,{children:[(0,l.jsxs)(s.mrow,{children:[(0,l.jsxs)(s.msub,{children:[(0,l.jsx)(s.mi,{mathvariant:"bold",children:"v"}),(0,l.jsxs)(s.mrow,{children:[(0,l.jsx)(s.mi,{mathvariant:"normal",children:"g"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"l"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"o"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"b"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"a"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"l"})]})]}),(0,l.jsx)(s.mo,{children:"="}),(0,l.jsx)(s.mi,{children:"W"}),(0,l.jsx)(s.mtext,{children:"\u2009"}),(0,l.jsxs)(s.msub,{children:[(0,l.jsx)(s.mi,{mathvariant:"bold",children:"v"}),(0,l.jsxs)(s.mrow,{children:[(0,l.jsx)(s.mi,{mathvariant:"normal",children:"l"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"o"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"c"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"a"}),(0,l.jsx)(s.mi,{mathvariant:"normal",children:"l"})]})]})]}),(0,l.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\mathbf{v}_{\\mathrm{global}} = W \\, \\mathbf{v}_{\\mathrm{local}}"})]})})}),(0,l.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,l.jsxs)(s.span,{className:"base",children:[(0,l.jsx)(s.span,{className:"strut",style:{height:"0.7305em",verticalAlign:"-0.2861em"}}),(0,l.jsxs)(s.span,{className:"mord",children:[(0,l.jsx)(s.span,{className:"mord mathbf",style:{marginRight:"0.01597em"},children:"v"}),(0,l.jsx)(s.span,{className:"msupsub",children:(0,l.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,l.jsxs)(s.span,{className:"vlist-r",children:[(0,l.jsx)(s.span,{className:"vlist",style:{height:"0.3361em"},children:(0,l.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.016em",marginRight:"0.05em"},children:[(0,l.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,l.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,l.jsx)(s.span,{className:"mord mtight",children:(0,l.jsx)(s.span,{className:"mord mtight",children:(0,l.jsx)(s.span,{className:"mord mathrm mtight",children:"global"})})})})]})}),(0,l.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,l.jsx)(s.span,{className:"vlist-r",children:(0,l.jsx)(s.span,{className:"vlist",style:{height:"0.2861em"},children:(0,l.jsx)(s.span,{})})})]})})]}),(0,l.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.jsx)(s.span,{className:"mrel",children:"="}),(0,l.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,l.jsxs)(s.span,{className:"base",children:[(0,l.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,l.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"W"}),(0,l.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,l.jsxs)(s.span,{className:"mord",children:[(0,l.jsx)(s.span,{className:"mord mathbf",style:{marginRight:"0.01597em"},children:"v"}),(0,l.jsx)(s.span,{className:"msupsub",children:(0,l.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,l.jsxs)(s.span,{className:"vlist-r",children:[(0,l.jsx)(s.span,{className:"vlist",style:{height:"0.3361em"},children:(0,l.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.016em",marginRight:"0.05em"},children:[(0,l.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,l.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,l.jsx)(s.span,{className:"mord mtight",children:(0,l.jsx)(s.span,{className:"mord mtight",children:(0,l.jsx)(s.span,{className:"mord mathrm mtight",children:"local"})})})})]})}),(0,l.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,l.jsx)(s.span,{className:"vlist-r",children:(0,l.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,l.jsx)(s.span,{})})})]})})]})]})]})]}),"\nThe columns of ",(0,l.jsx)(s.code,{children:"W"})," have a direct geometric meaning:"]}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"W[:, 0]"})," \u2014 local ",(0,l.jsx)(s.strong,{children:"x-axis"})," in global coordinates"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"W[:, 1]"})," \u2014 local ",(0,l.jsx)(s.strong,{children:"y-axis"})," in global coordinates"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"W[:, 2]"})," \u2014 local ",(0,l.jsx)(s.strong,{children:"s-axis"}),", i.e. the beam direction"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsxs)(s.p,{children:["Element ",(0,l.jsx)(s.code,{children:"tilt"})," represents a rotation around the local s-axis (MAD-8 convention)."]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["\n",(0,l.jsx)(s.p,{children:"The survey is purely geometric and does not affect beam dynamics or tracking."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h3,{id:"print_sequenceself-start-e--none-stop-e--none",children:(0,l.jsx)(s.code,{children:"print_sequence(self, start: E = None, stop: E = None)"})}),"\n",(0,l.jsx)(s.p,{children:"Prints the sequence of elements in the lattice, including their lengths and start/end positions."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-6",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"start"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),", optional): The element to start from in the sequence."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"stop"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(s.code,{children:"Element"})}),", optional): The element to stop at in the sequence."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-7",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A list of strings representing the sequence of elements."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"periodic_twissself-twsnone",children:(0,l.jsx)(s.code,{children:"periodic_twiss(self, tws=None)"})}),"\n",(0,l.jsx)(s.p,{children:"Calculates the periodic Twiss parameters for the lattice using transfer maps."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-7",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"tws"})," (",(0,l.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,l.jsx)(s.code,{children:"Twiss"})}),", optional): A ",(0,l.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,l.jsx)(s.code,{children:"Twiss"})})," object. If provided, the initial Twiss parameters will be used."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-8",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"The periodic Twiss parameters."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,l.jsx)(s,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>a});var t=n(6540);const l={},i=t.createContext(l);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);