"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[9867],{5469:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"docu/OCELOT fundamentals/tracking","title":"Tracking","description":"Particle tracking through a magnetic lattice with optional envelope calculation.","source":"@site/docs/docu/OCELOT fundamentals/tracking.md","sourceDirName":"docu/OCELOT fundamentals","slug":"/docu/OCELOT fundamentals/tracking","permalink":"/docs/docu/OCELOT fundamentals/tracking","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/OCELOT fundamentals/tracking.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Tracking","description":"Particle tracking through a magnetic lattice with optional envelope calculation."},"sidebar":"docsSidebar","previous":{"title":"Navigator","permalink":"/docs/docu/OCELOT fundamentals/navigator"},"next":{"title":"ParticleArray","permalink":"/docs/docu/OCELOT fundamentals/particle-array"}}');var c=n(4848),r=n(8453);const t={sidebar_position:7,title:"Tracking",description:"Particle tracking through a magnetic lattice with optional envelope calculation."},a="track function",l={},d=[{value:"Function Signature",id:"function-signature",level:2},{value:"Description",id:"description",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Key Operations within <code>track</code> (Conceptual Flow)",id:"key-operations-within-track-conceptual-flow",level:2},{value:"Notes",id:"notes",level:2}];function o(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mdxAdmonitionTitle:"mdxAdmonitionTitle",mi:"mi",mo:"mo",mrow:"mrow",msub:"msub",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(s.header,{children:(0,c.jsxs)(s.h1,{id:"track-function",children:[(0,c.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/track.py#L428",children:(0,c.jsx)(s.code,{children:"track"})})," function"]})}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"track"})," function is a core component in Ocelot for simulating particle beam dynamics through a ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/magnet-lattice",children:(0,c.jsx)(s.code,{children:"MagneticLattice"})}),".\nIt applies transformations from lattice elements and physics processes (like ",(0,c.jsx)(s.a,{href:"/docs/docu/physics-processes/sc",children:"Space Charge"}),",  ",(0,c.jsx)(s.a,{href:"/docs/docu/physics-processes/wake",children:"Wakefields"})," and etc.) to a ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,c.jsx)(s.code,{children:"ParticleArray"})}),".\nOptionally, it calculates beam envelope (Twiss) parameters at specified intervals using the ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," function."]}),"\n",(0,c.jsx)(s.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{className:"language-python",children:"def track(\n        lattice: MagneticLattice,\n        p_array: ParticleArray,\n        navi: Navigator = None,\n        print_progress: bool = True,\n        calc_tws: bool = True,\n        bounds: list = None,\n        return_df: bool = False,\n        overwrite_progress: bool = True,\n        slice: str = None, # Python 'slice' keyword is different\n        twiss_disp_correction: bool = False\n        ) -> Tuple[Union[List[Twiss], pd.DataFrame], ParticleArray]:\n    # ... function body ...\n    # Simplified conceptual flow:\n    # tws_initial = get_envelope(p_array, ...) if calc_tws else Twiss()\n    # tws_track = [tws_initial]\n    # for each step in navigator:\n    #     apply_transfer_maps(p_array, step_maps)\n    #     apply_physics_processes(p_array, step_processes)\n    #     if p_array is empty: break\n    #     if calc_tws:\n    #         current_tws = get_envelope(p_array, ...)\n    #         tws_track.append(current_tws)\n    #     print_progress_if_enabled()\n    # finalize_physics_processes()\n    # return tws_track, p_array\n    pass\n"})}),"\n",(0,c.jsx)(s.h2,{id:"description",children:"Description"}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"track"})," function simulates the passage of a ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,c.jsx)(s.code,{children:"ParticleArray"})})," through a given ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/magnet-lattice",children:(0,c.jsx)(s.code,{children:"MagneticLattice"})}),". It utilizes a ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/navigator",children:(0,c.jsx)(s.code,{children:"Navigator"})})," to determine the sequence of optical element transformations (transfer maps) and physics processes to apply."]}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["At each step dictated by the navigator, the corresponding transfer maps are applied to the ",(0,c.jsx)(s.code,{children:"p_array"}),"."]}),"\n",(0,c.jsx)(s.li,{children:"Subsequently, any physics processes scheduled for that step are applied."}),"\n",(0,c.jsxs)(s.li,{children:["If ",(0,c.jsx)(s.code,{children:"calc_tws"})," is true, beam statistics (Twiss parameters, moments, etc.) are calculated from the ",(0,c.jsx)(s.code,{children:"p_array"})," using the ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," function after each step. These intermediate Twiss parameters are accumulated and returned."]}),"\n",(0,c.jsx)(s.li,{children:"The tracking continues until the end of the lattice is reached or the particle array becomes empty."}),"\n"]}),"\n",(0,c.jsx)(s.h2,{id:"parameters",children:"Parameters"}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"lattice"})})," (",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/magnet-lattice",children:(0,c.jsx)(s.code,{children:"MagneticLattice"})}),")\nThe magnetic lattice structure through which the particles will be tracked."]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"p_array"})})," (",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,c.jsx)(s.code,{children:"ParticleArray"})}),")\nThe input array of particles to be tracked. This array is modified in place."]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"navi"})})," (",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/navigator",children:(0,c.jsx)(s.code,{children:"Navigator"})}),", optional)\nThe navigator object that orchestrates the tracking steps, including the application of physics processes. If ",(0,c.jsx)(s.code,{children:"None"})," (default), a basic ",(0,c.jsx)(s.code,{children:"Navigator"})," is instantiated for the given ",(0,c.jsx)(s.code,{children:"lattice"})," without any physics processes.\n",(0,c.jsxs)(s.em,{children:["Note: If providing a custom navigator, ensure its associated lattice is the same as the ",(0,c.jsx)(s.code,{children:"lattice"})," argument."]})]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"print_progress"})})," (",(0,c.jsx)(s.code,{children:"bool"}),", optional, default: ",(0,c.jsx)(s.code,{children:"True"}),")\nIf ",(0,c.jsx)(s.code,{children:"True"}),", prints the tracking progress to the console, indicating the current longitudinal position (",(0,c.jsx)(s.code,{children:"z"}),") and the physics processes being applied."]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"calc_tws"})})," (",(0,c.jsx)(s.code,{children:"bool"}),", optional, default: ",(0,c.jsx)(s.code,{children:"True"}),")\nIf ",(0,c.jsx)(s.code,{children:"True"}),", Twiss parameters and other beam envelope characteristics are calculated from the ",(0,c.jsx)(s.code,{children:"p_array"})," using ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," at the beginning and after each significant step in the lattice. The results are collected and returned. If ",(0,c.jsx)(s.code,{children:"False"}),", this calculation is skipped, and a list of empty ",(0,c.jsx)(s.code,{children:"Twiss"})," objects (or an empty DataFrame) is returned for the Twiss part of the output."]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"bounds"})})," (",(0,c.jsx)(s.code,{children:"list"}),", optional, default: ",(0,c.jsx)(s.code,{children:"None"}),")\nPassed directly to the ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," function when ",(0,c.jsx)(s.code,{children:"calc_tws"})," is ",(0,c.jsx)(s.code,{children:"True"}),". Defines longitudinal bounds ",(0,c.jsx)(s.code,{children:"[left_bound, right_bound]"})," in units of ",(0,c.jsxs)(s.span,{className:"katex",children:[(0,c.jsx)(s.span,{className:"katex-mathml",children:(0,c.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,c.jsxs)(s.semantics,{children:[(0,c.jsx)(s.mrow,{children:(0,c.jsxs)(s.msub,{children:[(0,c.jsx)(s.mi,{children:"\u03c3"}),(0,c.jsx)(s.mi,{children:"\u03c4"})]})}),(0,c.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\sigma_\\tau"})]})})}),(0,c.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,c.jsxs)(s.span,{className:"base",children:[(0,c.jsx)(s.span,{className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,c.jsxs)(s.span,{className:"mord",children:[(0,c.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"\u03c3"}),(0,c.jsx)(s.span,{className:"msupsub",children:(0,c.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,c.jsxs)(s.span,{className:"vlist-r",children:[(0,c.jsx)(s.span,{className:"vlist",style:{height:"0.1514em"},children:(0,c.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.0359em",marginRight:"0.05em"},children:[(0,c.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,c.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,c.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.1132em"},children:"\u03c4"})})]})}),(0,c.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,c.jsx)(s.span,{className:"vlist-r",children:(0,c.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,c.jsx)(s.span,{})})})]})})]})]})})]})," (standard deviation of ",(0,c.jsx)(s.code,{children:"p_array.tau()"}),") for slicing the particle distribution before calculating Twiss parameters. If ",(0,c.jsx)(s.code,{children:"None"}),", the full bunch is used."]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"return_df"})})," (",(0,c.jsx)(s.code,{children:"bool"}),", optional, default: ",(0,c.jsx)(s.code,{children:"False"}),")\nIf ",(0,c.jsx)(s.code,{children:"True"})," and ",(0,c.jsx)(s.code,{children:"calc_tws"})," is ",(0,c.jsx)(s.code,{children:"True"}),", the list of calculated ",(0,c.jsx)(s.code,{children:"Twiss"})," objects is converted into a pandas ",(0,c.jsx)(s.code,{children:"DataFrame"})," before being returned. This can be convenient for analysis and plotting."]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"overwrite_progress"})})," (",(0,c.jsx)(s.code,{children:"bool"}),", optional, default: ",(0,c.jsx)(s.code,{children:"True"}),")\nIf ",(0,c.jsx)(s.code,{children:"True"})," and ",(0,c.jsx)(s.code,{children:"print_progress"})," is ",(0,c.jsx)(s.code,{children:"True"}),", the progress message will overwrite the previous message on the same line in the console, creating a dynamic progress bar effect. If ",(0,c.jsx)(s.code,{children:"False"}),", each progress message is printed on a new line."]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"slice"})})," (",(0,c.jsx)(s.code,{children:"str"}),", optional, default: ",(0,c.jsx)(s.code,{children:"None"}),")\nPassed directly to the ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," function when ",(0,c.jsx)(s.code,{children:"calc_tws"})," is ",(0,c.jsx)(s.code,{children:"True"})," and ",(0,c.jsx)(s.code,{children:"bounds"})," are specified. Determines the reference point for longitudinal slicing:"]}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.code,{children:"None"}),": Uses the mean of ",(0,c.jsx)(s.code,{children:"p_array.tau()"})," (",(0,c.jsxs)(s.span,{className:"katex",children:[(0,c.jsx)(s.span,{className:"katex-mathml",children:(0,c.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,c.jsxs)(s.semantics,{children:[(0,c.jsxs)(s.mrow,{children:[(0,c.jsx)(s.mo,{stretchy:"false",children:"\u27e8"}),(0,c.jsx)(s.mi,{children:"\u03c4"}),(0,c.jsx)(s.mo,{stretchy:"false",children:"\u27e9"})]}),(0,c.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\langle \\tau \\rangle"})]})})}),(0,c.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,c.jsxs)(s.span,{className:"base",children:[(0,c.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,c.jsx)(s.span,{className:"mopen",children:"\u27e8"}),(0,c.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.1132em"},children:"\u03c4"}),(0,c.jsx)(s.span,{className:"mclose",children:"\u27e9"})]})})]}),")."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.code,{children:'"Imax"'}),": Uses the longitudinal position of maximum current."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"twiss_disp_correction"})})," (",(0,c.jsx)(s.code,{children:"bool"}),", optional, default: ",(0,c.jsx)(s.code,{children:"False"}),")\nPassed directly to the ",(0,c.jsx)(s.code,{children:"auto_disp"})," parameter of the ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," function when ",(0,c.jsx)(s.code,{children:"calc_tws"})," is ",(0,c.jsx)(s.code,{children:"True"}),". If ",(0,c.jsx)(s.code,{children:"True"}),", ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," will attempt to estimate and subtract the linear dispersion effects from the particle statistics when calculating Twiss parameters. This is useful for obtaining betatron Twiss parameters in dispersive regions."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(s.h2,{id:"returns",children:"Returns"}),"\n",(0,c.jsxs)(s.p,{children:["A tuple: ",(0,c.jsx)(s.code,{children:"(tws_results, p_array_final)"})]}),"\n",(0,c.jsxs)(s.ol,{children:["\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"tws_track"})})," (",(0,c.jsx)(s.code,{children:"List[Twiss]"})," or ",(0,c.jsx)(s.code,{children:"pd.DataFrame"}),")"]}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["If ",(0,c.jsx)(s.code,{children:"calc_tws"})," is ",(0,c.jsx)(s.code,{children:"True"}),": A list of ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," objects, each representing the beam envelope parameters at different points along the lattice (including the start). The ",(0,c.jsx)(s.code,{children:"s"})," coordinate of each ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," object indicates its longitudinal position. If ",(0,c.jsx)(s.code,{children:"return_df"})," is ",(0,c.jsx)(s.code,{children:"True"}),", this will be a pandas ",(0,c.jsx)(s.code,{children:"DataFrame"})," derived from these ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," objects."]}),"\n",(0,c.jsxs)(s.li,{children:["If ",(0,c.jsx)(s.code,{children:"calc_tws"})," is ",(0,c.jsx)(s.code,{children:"False"}),": A list containing initial and final empty ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," objects, or an empty DataFrame if ",(0,c.jsx)(s.code,{children:"return_df"})," is ",(0,c.jsx)(s.code,{children:"True"}),". ",(0,c.jsx)(s.em,{children:"(The actual behavior based on your code seems to be: an initial empty Twiss, and subsequent empty Twiss objects for each step)"}),". The provided code returns a list containing an initial ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," object (either calculated or empty) and appends one more ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," object per ",(0,c.jsx)(s.code,{children:"navi.get_next_step()"})," iteration."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:(0,c.jsx)(s.code,{children:"p_array_final"})})," (",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,c.jsx)(s.code,{children:"ParticleArray"})}),")\nThe ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,c.jsx)(s.code,{children:"ParticleArray"})})," after all tracking steps and physics processes have been applied. This is the same ",(0,c.jsx)(s.code,{children:"p_array"})," object passed as input, modified in place."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(s.admonition,{type:"warning",children:[(0,c.jsxs)(s.mdxAdmonitionTitle,{children:["Important: In-Place Modification of ",(0,c.jsx)(s.code,{children:"p_array"})]}),(0,c.jsxs)(s.p,{children:["The input ",(0,c.jsx)(s.code,{children:"p_array"})," object is modified ",(0,c.jsx)(s.strong,{children:"in-place"})," during the execution of the ",(0,c.jsx)(s.code,{children:"track"})," function. Consequently, the returned ",(0,c.jsx)(s.code,{children:"p_array_final"})," is the same object as the input ",(0,c.jsx)(s.code,{children:"p_array"}),", now reflecting its state after tracking."]}),(0,c.jsxs)(s.p,{children:["While returning ",(0,c.jsx)(s.code,{children:"p_array_final"})," might seem redundant given the in-place modification, this behavior is maintained for consistency with existing scripts and a common functional programming pattern of returning outputs. Users should be aware that any references to the original ",(0,c.jsx)(s.code,{children:"p_array"})," outside the function will also point to the modified particle data. If the original state of ",(0,c.jsx)(s.code,{children:"p_array"})," needs to be preserved, create a copy before calling ",(0,c.jsx)(s.code,{children:"track()"})," (e.g., ",(0,c.jsx)(s.code,{children:"p_array_copy = p_array.copy()"}),")."]})]}),"\n",(0,c.jsxs)(s.h2,{id:"key-operations-within-track-conceptual-flow",children:["Key Operations within ",(0,c.jsx)(s.code,{children:"track"})," (Conceptual Flow)"]}),"\n",(0,c.jsxs)(s.ol,{children:["\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Initialization:"})}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["A default ",(0,c.jsx)(s.code,{children:"Navigator"})," is created if one isn't provided."]}),"\n",(0,c.jsxs)(s.li,{children:["If ",(0,c.jsx)(s.code,{children:"calc_tws"})," is enabled, initial Twiss parameters are calculated using ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})})," with the specified ",(0,c.jsx)(s.code,{children:"bounds"}),", ",(0,c.jsx)(s.code,{children:"slice"}),", and ",(0,c.jsx)(s.code,{children:"twiss_disp_correction"})," settings. This initial ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," object is stored."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsxs)(s.p,{children:[(0,c.jsxs)(s.strong,{children:["Tracking Loop (Iterating through ",(0,c.jsx)(s.code,{children:"navi.get_next_step()"}),"):"]}),"\nThe navigator yields steps, each typically comprising:"]}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.code,{children:"t_maps"}),": A list of transfer map objects (e.g., from drift, quadrupole)."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.code,{children:"dz"}),": The length of this step."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.code,{children:"proc_list"}),": A list of physics process objects to be applied during this step."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.code,{children:"phys_steps"}),": The integration lengths for each process in ",(0,c.jsx)(s.code,{children:"proc_list"}),"."]}),"\n"]}),"\n",(0,c.jsx)(s.p,{children:"For each such step from the navigator:"}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.strong,{children:"Apply Transfer Maps:"})," Each transfer map in ",(0,c.jsx)(s.code,{children:"t_maps"})," is applied to the ",(0,c.jsx)(s.code,{children:"p_array"}),"."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.strong,{children:"Apply Physics Processes:"})," Each physics process in ",(0,c.jsx)(s.code,{children:"proc_list"})," is applied to the ",(0,c.jsx)(s.code,{children:"p_array"})," over its corresponding ",(0,c.jsx)(s.code,{children:"z_step"}),"."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.strong,{children:"Check Particle Count:"})," If ",(0,c.jsx)(s.code,{children:"p_array.n"})," (number of particles) becomes zero, tracking stops."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.strong,{children:"Calculate Twiss (if enabled):"})," ",(0,c.jsx)(s.code,{children:"get_envelope"})," is called again on the (now updated) ",(0,c.jsx)(s.code,{children:"p_array"})," with the same ",(0,c.jsx)(s.code,{children:"bounds"}),", ",(0,c.jsx)(s.code,{children:"slice"}),", and ",(0,c.jsx)(s.code,{children:"twiss_disp_correction"})," settings. The ",(0,c.jsx)(s.code,{children:"s"})," coordinate of the resulting ",(0,c.jsx)(s.code,{children:"Twiss"})," object is updated to reflect the current total path length ",(0,c.jsx)(s.code,{children:"L"}),". This new ",(0,c.jsx)(s.code,{children:"Twiss"})," object is appended to ",(0,c.jsx)(s.code,{children:"tws_track"}),"."]}),"\n",(0,c.jsxs)(s.li,{children:[(0,c.jsx)(s.strong,{children:"Print Progress (if enabled):"})," Information about the current position ",(0,c.jsx)(s.code,{children:"z"})," and applied processes is printed."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Finalization:"})}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["After the loop, any ",(0,c.jsx)(s.code,{children:"finalize()"})," methods of the physics processes registered with the navigator are called."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Return Values:"})}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["The accumulated list of ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,c.jsx)(s.code,{children:"Twiss"})})," objects (or DataFrame) and the final state of the ",(0,c.jsx)(s.code,{children:"p_array"})," are returned."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(s.h2,{id:"notes",children:"Notes"}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["The ",(0,c.jsx)(s.code,{children:"p_array"})," is modified ",(0,c.jsx)(s.strong,{children:"in place"})," throughout the tracking. If you need to preserve the initial ",(0,c.jsx)(s.code,{children:"p_array"}),", make a copy before calling ",(0,c.jsx)(s.code,{children:"track"})," (e.g., ",(0,c.jsx)(s.code,{children:"p_array_copy = p_array.copy()"}),")."]}),"\n",(0,c.jsxs)(s.li,{children:["The accuracy and types of physical effects included depend on the ",(0,c.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/navigator",children:(0,c.jsx)(s.code,{children:"Navigator"})})," setup and the ",(0,c.jsx)(s.a,{href:"/docs/docu/physics-processes/phys-proc",children:(0,c.jsx)(s.code,{children:"PhysProc"})})," objects added to it."]}),"\n",(0,c.jsxs)(s.li,{children:["Parameters ",(0,c.jsx)(s.code,{children:"bounds"}),", ",(0,c.jsx)(s.code,{children:"slice"}),", and ",(0,c.jsx)(s.code,{children:"twiss_disp_correction"})," directly influence how the intermediate Twiss parameters are calculated by ",(0,c.jsx)(s.a,{href:"/docs/docu/functions/get_envelope",children:(0,c.jsx)(s.code,{children:"get_envelope"})}),", allowing for flexible analysis (e.g., sliced analysis, dispersion-corrected betatron functions)."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,c.jsx)(s,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>a});var i=n(6540);const c={},r=i.createContext(c);function t(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);