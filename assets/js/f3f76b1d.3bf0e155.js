"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[508],{834:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"docu/physics-processes/sc","title":"Space Charge","description":"Space Charge class","source":"@site/docs/docu/physics-processes/sc.md","sourceDirName":"docu/physics-processes","slug":"/docu/physics-processes/sc","permalink":"/docs/docu/physics-processes/sc","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/physics-processes/sc.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Space Charge","description":"Space Charge class"},"sidebar":"docsSidebar","previous":{"title":"PhysProc Parent Class","permalink":"/docs/docu/physics-processes/phys-proc"},"next":{"title":"Wakefields","permalink":"/docs/docu/physics-processes/wake"}}');var n=a(4848),t=a(8453);const r={sidebar_position:2,title:"Space Charge",description:"Space Charge class"},l="SpaceCharge Class",c={},o=[{value:"Parameters:",id:"parameters",level:3},{value:"Methods:",id:"methods",level:3},{value:"<code>__init__(self, step=1, **kwargs)</code>",id:"__init__self-step1-kwargs",level:4},{value:"<code>prepare(self, lat)</code>",id:"prepareself-lat",level:4},{value:"<code>sym_kernel(self, ijk2, hxyz)</code>",id:"sym_kernelself-ijk2-hxyz",level:4},{value:"<code>potential(self, q, steps)</code>",id:"potentialself-q-steps",level:4},{value:"<code>el_field(self, X, Q, gamma, nxyz)</code>",id:"el_fieldself-x-q-gamma-nxyz",level:4},{value:"<code>apply(self, p_array, zstep)</code>",id:"applyself-p_array-zstep",level:4},{value:"<code>__repr__(self) -&gt; str</code>",id:"__repr__self---str",level:4},{value:"Summary",id:"summary",level:2},{value:"Space Charge Example",id:"space-charge-example",level:2},{value:"Step-by-Step",id:"step-by-step",level:3},{value:"Purpose",id:"purpose",level:2},{value:"Parameters",id:"parameters-1",level:2},{value:"Methods",id:"methods-1",level:2},{value:"<code>__init__(self, step=1, smooth_param=0.1, step_profile=False)</code>",id:"__init__self-step1-smooth_param01-step_profilefalse",level:3},{value:"<code>apply(self, p_array, dz)</code>",id:"applyself-p_array-dz",level:3},{value:"<code>imp_lsc(self, gamma, sigma, w, dz)</code>",id:"imp_lscself-gamma-sigma-w-dz",level:3},{value:"<code>imp_step_lsc(self, gamma, rb, w, dz)</code>",id:"imp_step_lscself-gamma-rb-w-dz",level:3},{value:"<code>wake2impedance(self, s, w)</code>",id:"wake2impedanceself-s-w",level:3},{value:"<code>impedance2wake(self, f, y)</code>",id:"impedance2wakeself-f-y",level:3},{value:"<code>wake_lsc(self, s, bunch, gamma, sigma, dz)</code>",id:"wake_lscself-s-bunch-gamma-sigma-dz",level:3},{value:"<code>finalize(self, *args, **kwargs)</code>",id:"finalizeself-args-kwargs",level:3},{value:"<code>calculate_csr_wakes(self)</code>",id:"calculate_csr_wakesself",level:3},{value:"<code>plot_wake(self, p_array, lam_K1, itr_ra, s1, st)</code>",id:"plot_wakeself-p_array-lam_k1-itr_ra-s1-st",level:3},{value:"Summary",id:"summary-1",level:2}];function d(e){const s={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsxs)(s.h1,{id:"spacecharge-class",children:[(0,n.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/sc.py#L74",children:"SpaceCharge"})," Class"]})}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/sc.py#L74",children:(0,n.jsx)(s.code,{children:"SpaceCharge"})}),"  class models the space charge forces in a particle beam by solving the Poisson equation in the bunch frame.\nThen the Lorentz transformed electromagnetic field is applied as a kick in the laboratory frame.\nFor the solution of the Poisson equation we use an integral representation of the electrostatic potential\nby convolution of the free-space Green's function with the charge distribution.\nThe convolution equation is solved with the help of the Fast Fourier Transform (FFT). The same algorithm for\nsolution of the 3D Poisson equation is used, for example, in ASTRA."]}),"\n",(0,n.jsx)(s.h3,{id:"parameters",children:"Parameters:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"step"})," (",(0,n.jsx)(s.code,{children:"int"}),"): Step size used in unit steps. Default is ",(0,n.jsx)(s.code,{children:"1"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"nmesh_xyz"})," (",(0,n.jsx)(s.code,{children:"list"}),"): Defines the number of mesh points in each dimension for the 3D mesh. Default is ",(0,n.jsx)(s.code,{children:"[63, 63, 63]"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"low_order_kick"})," (",(0,n.jsx)(s.code,{children:"bool"}),"): Whether to use a low-order approximation for the kick. Default is ",(0,n.jsx)(s.code,{children:"True"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"random_mesh"})," (",(0,n.jsx)(s.code,{children:"bool"}),"): If ",(0,n.jsx)(s.code,{children:"True"}),", the mesh is shifted slightly at each step to reduce numerical noise. Default is ",(0,n.jsx)(s.code,{children:"False"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"random_seed"})," (",(0,n.jsx)(s.code,{children:"int"}),"): Seed for random number generation when ",(0,n.jsx)(s.code,{children:"random_mesh"})," is ",(0,n.jsx)(s.code,{children:"True"}),". Default is ",(0,n.jsx)(s.code,{children:"10"}),"."]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"methods",children:"Methods:"}),"\n",(0,n.jsx)(s.h4,{id:"__init__self-step1-kwargs",children:(0,n.jsx)(s.code,{children:"__init__(self, step=1, **kwargs)"})}),"\n",(0,n.jsxs)(s.p,{children:["Constructor to initialize the ",(0,n.jsx)(s.code,{children:"SpaceCharge"})," class with the specified parameters. It sets up the mesh, the randomization flag, and the random seed."]}),"\n",(0,n.jsx)(s.h4,{id:"prepareself-lat",children:(0,n.jsx)(s.code,{children:"prepare(self, lat)"})}),"\n",(0,n.jsx)(s.p,{children:"Prepares the simulation by checking the step size and setting the random seed if necessary."}),"\n",(0,n.jsx)(s.h4,{id:"sym_kernelself-ijk2-hxyz",children:(0,n.jsx)(s.code,{children:"sym_kernel(self, ijk2, hxyz)"})}),"\n",(0,n.jsx)(s.p,{children:"Computes the symmetric kernel for the 3D Poisson equation solution using the convolution method. The kernel is used to calculate the electrostatic potential in the beam."}),"\n",(0,n.jsx)(s.h4,{id:"potentialself-q-steps",children:(0,n.jsx)(s.code,{children:"potential(self, q, steps)"})}),"\n",(0,n.jsxs)(s.p,{children:["Solves the Poisson equation for the electrostatic potential in the beam, given the charge distribution (",(0,n.jsx)(s.code,{children:"q"}),") and step sizes (",(0,n.jsx)(s.code,{children:"steps"}),"). This method uses the Fast Fourier Transform (FFT) for efficient computation."]}),"\n",(0,n.jsx)(s.h4,{id:"el_fieldself-x-q-gamma-nxyz",children:(0,n.jsx)(s.code,{children:"el_field(self, X, Q, gamma, nxyz)"})}),"\n",(0,n.jsx)(s.p,{children:"Calculates the electric field in the rest frame of the bunch by using a 3D interpolation method. The result is Lorentz transformed to the laboratory frame."}),"\n",(0,n.jsx)(s.h4,{id:"applyself-p_array-zstep",children:(0,n.jsx)(s.code,{children:"apply(self, p_array, zstep)"})}),"\n",(0,n.jsxs)(s.p,{children:["Applies the space charge kick to the particle array (",(0,n.jsx)(s.code,{children:"p_array"}),") over a given path length (",(0,n.jsx)(s.code,{children:"zstep"}),"). The method computes the electric field and updates the particle momenta according to the space charge forces."]}),"\n",(0,n.jsx)(s.h4,{id:"__repr__self---str",children:(0,n.jsx)(s.code,{children:"__repr__(self) -> str"})}),"\n",(0,n.jsxs)(s.p,{children:["Returns a string representation of the ",(0,n.jsx)(s.code,{children:"SpaceCharge"})," class, including key parameters like step size, mesh resolution, and randomization settings."]}),"\n",(0,n.jsx)(s.hr,{}),"\n",(0,n.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"SpaceCharge"})," class simulates the space charge forces acting on a particle beam by solving the Poisson equation for the beam's charge distribution. The class computes the electric field using a convolution method and applies the resulting forces as kicks to the particle array. This model is crucial for understanding beam dynamics, especially in high-intensity beams where space charge effects are significant."]}),"\n",(0,n.jsx)(s.hr,{}),"\n",(0,n.jsx)(s.h2,{id:"space-charge-example",children:"Space Charge Example"}),"\n",(0,n.jsx)(s.p,{children:"This example demonstrates how to simulate the impact of 3D space charge forces on the evolution of a particle beam\nthrough a simple FODO-like lattice. We compare tracking with and without space charge effects by plotting the resulting beta functions."}),"\n",(0,n.jsx)(s.h3,{id:"step-by-step",children:"Step-by-Step"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'from ocelot import *\nfrom ocelot.gui import *\n\n# 1. Generate a test particle array with defined Twiss parameters\nparray_init = generate_parray(\n    nparticles=100000,\n    tws=Twiss(beta_x=10, beta_y=10, E=0.01),  # E = 10 MeV\n    sigma_tau=1e-4\n)\n\n# 2. Define a simple FODO-like lattice\nqf = Quadrupole(l=0.2, k1=2)\nqd = Quadrupole(l=0.2, k1=-2)\nd = Drift(l=1)\nm1 = Marker()  # Start of section\nm2 = Marker()  # End of section\n\nlat = MagneticLattice([m1, d, qf, d, qd, d, m2])\n\n# 3. Tracking WITHOUT space charge\n# Create navigator with step size 0.1 m\nnavi = Navigator(lat, unit_step=0.1)\n\n# Add a dummy physics process to force tracking every step\nemp = EmptyProc()\nnavi.add_physics_proc(emp, m1, m2)\n\nparray = parray_init.copy()\ntws_track_no_sc, _ = track(lat, parray, navi)\n\n# 4. Tracking WITH 3D space charge\nnavi = Navigator(lat, unit_step=0.1)\n\n# Create space charge process with default 3D mesh resolution\nsc = SpaceCharge(nmesh_xyz=[63, 63, 63])\nnavi.add_physics_proc(sc, m1, m2)\n\nparray = parray_init.copy()\ntws_track_w_sc, _ = track(lat, parray, navi)\n\n# 5. Plot beta functions with and without SC\nfig, (ax_x, ax_y) = plot_API(lat, add_extra_subplot=True)\n\n# Extract beta functions\ns_no  = [tw.s for tw in tws_track_no_sc]\nbx_no = [tw.beta_x for tw in tws_track_no_sc]\nby_no = [tw.beta_y for tw in tws_track_no_sc]\n\ns_sc  = [tw.s for tw in tws_track_w_sc]\nbx_sc = [tw.beta_x for tw in tws_track_w_sc]\nby_sc = [tw.beta_y for tw in tws_track_w_sc]\n\n# Plot horizontal beta functions\nax_x.plot(s_no, bx_no, label="SC OFF")\nax_x.plot(s_sc, bx_sc, label="SC ON")\nax_x.set_ylabel(r"$\\beta_x$ [m]")\nax_x.legend()\n\n# Plot vertical beta functions\nax_y.plot(s_no, by_no, label="SC OFF")\nax_y.plot(s_sc, by_sc, label="SC ON")\nax_y.set_ylabel(r"$\\beta_y$ [m]")\nax_y.set_xlabel("s [m]")\nax_y.legend()\n\nplt.show()\n'})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"png",src:a(1312).A+"",width:"640",height:"480"})}),"\n",(0,n.jsx)(s.h1,{id:"longitudinal-space-charge-lsc",children:(0,n.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/sc.py#L258",children:"Longitudinal Space Charge (LSC)"})}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/sc.py#L258",children:(0,n.jsx)(s.code,{children:"LSC"})})," class simulates ",(0,n.jsx)(s.strong,{children:"longitudinal space charge effects"})," in particle beams.\nThese effects arise due to the interaction of charged particles within a bunch,\ngenerating self-induced electric fields that distort the longitudinal phase space.\nThis is particularly important for high-brightness or high-charge beams at low to moderate energies."]}),"\n",(0,n.jsx)(s.p,{children:"The space charge impedance is computed either for a smooth Gaussian-like distribution or using a stepped-profile approximation.\nThe resulting wakefield is applied as a longitudinal kick to the beam during tracking."}),"\n",(0,n.jsx)(s.hr,{}),"\n",(0,n.jsx)(s.h2,{id:"purpose",children:"Purpose"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"LSC"})," class models the ",(0,n.jsx)(s.strong,{children:"1D longitudinal space charge impedance"})," and applies it to the beam using ",(0,n.jsx)(s.strong,{children:"FFT-based wakefield computations"}),".\nIt allows users to choose between a smooth or stepped profile for the bunch and includes options for tuning\nthe resolution of the impedance calculation."]}),"\n",(0,n.jsx)(s.hr,{}),"\n",(0,n.jsx)(s.h2,{id:"parameters-1",children:"Parameters"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"step"})," (",(0,n.jsx)(s.em,{children:"int"}),", default=",(0,n.jsx)(s.code,{children:"1"}),"):",(0,n.jsx)(s.br,{}),"\n","Number of ",(0,n.jsx)(s.code,{children:"Navigator.unit_step"})," segments between kicks. A ",(0,n.jsx)(s.code,{children:"step=1"})," means the wake is applied at each step."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"smooth_param"})," (",(0,n.jsx)(s.em,{children:"float"}),", default=",(0,n.jsx)(s.code,{children:"0.1"}),"):",(0,n.jsx)(s.br,{}),"\n","Defines the smoothing resolution of the longitudinal profile as",(0,n.jsx)(s.br,{}),"\n",(0,n.jsx)(s.code,{children:"resolution = std(p_array.tau()) * smooth_param"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"step_profile"})," (",(0,n.jsx)(s.em,{children:"bool"}),", default=",(0,n.jsx)(s.code,{children:"False"}),"):",(0,n.jsx)(s.br,{}),"\n","If ",(0,n.jsx)(s.code,{children:"True"}),", uses a stepped profile approximation of the beam.",(0,n.jsx)(s.br,{}),"\n","If ",(0,n.jsx)(s.code,{children:"False"}),", assumes a continuous longitudinal profile."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.hr,{}),"\n",(0,n.jsx)(s.h2,{id:"methods-1",children:"Methods"}),"\n",(0,n.jsx)(s.h3,{id:"__init__self-step1-smooth_param01-step_profilefalse",children:(0,n.jsx)(s.code,{children:"__init__(self, step=1, smooth_param=0.1, step_profile=False)"})}),"\n",(0,n.jsxs)(s.p,{children:["Initializes the ",(0,n.jsx)(s.code,{children:"LSC"})," process with user-defined parameters."]}),"\n",(0,n.jsx)(s.h3,{id:"applyself-p_array-dz",children:(0,n.jsx)(s.code,{children:"apply(self, p_array, dz)"})}),"\n",(0,n.jsxs)(s.p,{children:["Applies the longitudinal space charge kick to a particle array over a longitudinal step ",(0,n.jsx)(s.code,{children:"dz"}),".",(0,n.jsx)(s.br,{}),"\n","Modifies particle momenta based on the calculated wakefield."]}),"\n",(0,n.jsx)(s.h3,{id:"imp_lscself-gamma-sigma-w-dz",children:(0,n.jsx)(s.code,{children:"imp_lsc(self, gamma, sigma, w, dz)"})}),"\n",(0,n.jsxs)(s.p,{children:["Computes the longitudinal space charge impedance for a Gaussian-like distribution using beam energy ",(0,n.jsx)(s.code,{children:"gamma"}),", transverse size ",(0,n.jsx)(s.code,{children:"sigma"}),", frequency ",(0,n.jsx)(s.code,{children:"w"}),", and step size ",(0,n.jsx)(s.code,{children:"dz"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"imp_step_lscself-gamma-rb-w-dz",children:(0,n.jsx)(s.code,{children:"imp_step_lsc(self, gamma, rb, w, dz)"})}),"\n",(0,n.jsxs)(s.p,{children:["Computes the impedance for a stepped beam profile. ",(0,n.jsx)(s.code,{children:"rb"})," is the effective transverse beam radius."]}),"\n",(0,n.jsx)(s.h3,{id:"wake2impedanceself-s-w",children:(0,n.jsx)(s.code,{children:"wake2impedance(self, s, w)"})}),"\n",(0,n.jsxs)(s.p,{children:["Converts wakefield data ",(0,n.jsx)(s.code,{children:"w"})," into impedance via a forward Fourier transform (",(0,n.jsx)(s.code,{children:"exp(iwt)"}),")."]}),"\n",(0,n.jsx)(s.h3,{id:"impedance2wakeself-f-y",children:(0,n.jsx)(s.code,{children:"impedance2wake(self, f, y)"})}),"\n",(0,n.jsxs)(s.p,{children:["Performs an inverse Fourier transform (",(0,n.jsx)(s.code,{children:"exp(-iwt)"}),") to compute wakefield from impedance data."]}),"\n",(0,n.jsx)(s.h3,{id:"wake_lscself-s-bunch-gamma-sigma-dz",children:(0,n.jsx)(s.code,{children:"wake_lsc(self, s, bunch, gamma, sigma, dz)"})}),"\n",(0,n.jsx)(s.p,{children:"Computes the wakefield in real space for a given bunch distribution and beam parameters."}),"\n",(0,n.jsx)(s.h3,{id:"finalizeself-args-kwargs",children:(0,n.jsx)(s.code,{children:"finalize(self, *args, **kwargs)"})}),"\n",(0,n.jsx)(s.p,{children:"Finalizes the space charge computation at the end of tracking. Reserved for cleanup or optional output."}),"\n",(0,n.jsx)(s.h3,{id:"calculate_csr_wakesself",children:(0,n.jsx)(s.code,{children:"calculate_csr_wakes(self)"})}),"\n",(0,n.jsx)(s.p,{children:"(Deprecated or internal use) Placeholder for compatibility with CSR-based wake computation."}),"\n",(0,n.jsx)(s.h3,{id:"plot_wakeself-p_array-lam_k1-itr_ra-s1-st",children:(0,n.jsx)(s.code,{children:"plot_wake(self, p_array, lam_K1, itr_ra, s1, st)"})}),"\n",(0,n.jsx)(s.p,{children:"Visualizes the longitudinal wake for diagnostic purposes. Intended for internal debugging or analysis."}),"\n",(0,n.jsx)(s.hr,{}),"\n",(0,n.jsx)(s.h2,{id:"summary-1",children:"Summary"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"LSC"})," class is part of the collective effects module in Ocelot. It provides a physics process that can be\ninserted into a beamline and used with the ",(0,n.jsx)(s.code,{children:"Navigator"})," class to track particle beams under the influence of longitudinal\nspace charge effects. The class offers flexibility in modeling beam profiles and efficiently computes impedance and wakefield using FFT methods."]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1312:(e,s,a)=>{a.d(s,{A:()=>i});const i=a.p+"assets/images/sc_exmp-f3f8f156ffc81cf79bc9b8654d462d1d.png"},8453:(e,s,a)=>{a.d(s,{R:()=>r,x:()=>l});var i=a(6540);const n={},t=i.createContext(n);function r(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);