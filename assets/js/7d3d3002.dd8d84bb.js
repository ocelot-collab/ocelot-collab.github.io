"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[4244],{7271:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"docu/physics-processes/phys-proc","title":"PhysProc Parent Class","description":"Parent class","source":"@site/docs/docu/physics-processes/phys-proc.md","sourceDirName":"docu/physics-processes","slug":"/docu/physics-processes/phys-proc","permalink":"/docs/docu/physics-processes/phys-proc","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/physics-processes/phys-proc.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"PhysProc Parent Class","description":"Parent class"},"sidebar":"docsSidebar","previous":{"title":"Physics Processes","permalink":"/docs/category/physics-processes"},"next":{"title":"Space Charge","permalink":"/docs/docu/physics-processes/sc"}}');var r=n(4848),c=n(8453);const t={sidebar_position:1,title:"PhysProc Parent Class",description:"Parent class"},l="PhysProc Class",d={},o=[{value:"Overview",id:"overview",level:2},{value:"Attributes",id:"attributes",level:2},{value:"Instance Attributes",id:"instance-attributes",level:3},{value:"Constructor",id:"constructor",level:2},{value:"<code>__init__(step=1)</code>",id:"__init__step1",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>check_step()</code>",id:"check_step",level:3},{value:"<code>prepare(lat)</code> <em>(optional)</em>",id:"preparelat-optional",level:3},{value:"<code>apply(p_array, dz)</code> <strong>(Required)</strong>",id:"applyp_array-dz-required",level:3},{value:"<code>finalize(*args, **kwargs)</code> <em>(optional)</em>",id:"finalizeargs-kwargs-optional",level:3},{value:"Notes",id:"notes",level:2},{value:"Related Classes",id:"related-classes",level:2}];function a(e){const s={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsxs)(s.h1,{id:"physproc-class",children:[(0,r.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/physics_proc.py#L14",children:"PhysProc"})," Class"]})}),"\n",(0,r.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/physics_proc.py#L14",children:(0,r.jsx)(s.code,{children:"PhysProc"})})," class serves as\nthe parent class for all physics processes within a simulation. It provides a standard interface for handling processes that interact with the ",(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/navigator",children:(0,r.jsx)(s.code,{children:"Navigator"})}),",\n",(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,r.jsx)(s.code,{children:"ParticleArray"})}),", and ",(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/magnet-lattice",children:(0,r.jsx)(s.code,{children:"MagneticLattice"})})," during beam tracking."]}),"\n",(0,r.jsxs)(s.p,{children:["This class is designed to be ",(0,r.jsx)(s.strong,{children:"extended"})," for defining custom physics effects such as ",(0,r.jsx)(s.a,{href:"/docs/docu/physics-processes/csr",children:"CSR"}),", ",(0,r.jsx)(s.a,{href:"/docs/docu/physics-processes/sc",children:"space charge"}),",\n",(0,r.jsx)(s.a,{href:"/docs/docu/physics-processes/wake",children:"wakefields"}),", ",(0,r.jsx)(s.a,{href:"/docs/docu/physics-processes/laser-modulator",children:"laser modulator"}),", and more."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"attributes",children:"Attributes"}),"\n",(0,r.jsx)(s.h3,{id:"instance-attributes",children:"Instance Attributes"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"step"})})," ",(0,r.jsx)(s.em,{children:"(int)"}),":",(0,r.jsx)(s.br,{}),"\n","Number of steps in ",(0,r.jsx)(s.code,{children:"Navigator.unit_step"}),". Each physics process applies over a distance of ",(0,r.jsx)(s.code,{children:"self.step * Navigator.unit_step"})," (measured in meters). Default is ",(0,r.jsx)(s.code,{children:"1"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"energy"})})," ",(0,r.jsx)(s.em,{children:"(float, optional)"}),":",(0,r.jsx)(s.br,{}),"\n","Beam energy associated with the process. Default is ",(0,r.jsx)(s.code,{children:"None"}),". Can be manually set or inferred during tracking."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"indx0"})})," ",(0,r.jsx)(s.em,{children:"(int, optional)"}),":",(0,r.jsx)(s.br,{}),"\n","Index of the starting element in the lattice sequence. Assigned during ",(0,r.jsx)(s.code,{children:"navigator.add_physics_proc()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"indx1"})})," ",(0,r.jsx)(s.em,{children:"(int, optional)"}),":",(0,r.jsx)(s.br,{}),"\n","Index of the stopping element in the lattice sequence. Assigned during ",(0,r.jsx)(s.code,{children:"navigator.add_physics_proc()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"s_start"})})," ",(0,r.jsx)(s.em,{children:"(float, optional)"}),":",(0,r.jsx)(s.br,{}),"\n","Position of the starting element in the lattice. Assigned during ",(0,r.jsx)(s.code,{children:"navigator.add_physics_proc()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"s_stop"})})," ",(0,r.jsx)(s.em,{children:"(float, optional)"}),":",(0,r.jsx)(s.br,{}),"\n","Position of the stopping element in the lattice. Assigned during ",(0,r.jsx)(s.code,{children:"navigator.add_physics_proc()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"z0"})})," ",(0,r.jsx)(s.em,{children:"(float, optional)"}),":",(0,r.jsx)(s.br,{}),"\n","Current longitudinal position in the beamline. Updated during tracking before each ",(0,r.jsx)(s.code,{children:"apply()"})," call."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"constructor",children:"Constructor"}),"\n",(0,r.jsx)(s.h3,{id:"__init__step1",children:(0,r.jsx)(s.code,{children:"__init__(step=1)"})}),"\n",(0,r.jsxs)(s.p,{children:["Initializes a new instance of the ",(0,r.jsx)(s.code,{children:"PhysProc"})," class."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"step"})," ",(0,r.jsx)(s.em,{children:"(int, optional)"}),": The number of steps in ",(0,r.jsx)(s.code,{children:"Navigator.unit_step"}),". Default is ",(0,r.jsx)(s.code,{children:"1"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(s.h3,{id:"check_step",children:(0,r.jsx)(s.code,{children:"check_step()"})}),"\n",(0,r.jsxs)(s.p,{children:["Validates that the ",(0,r.jsx)(s.code,{children:"step"})," attribute is an integer."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Raises:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"ValueError"}),": If ",(0,r.jsx)(s.code,{children:"self.step"})," is not an integer."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["This is called automatically by the default ",(0,r.jsx)(s.code,{children:"prepare()"})," method."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h3,{id:"preparelat-optional",children:[(0,r.jsx)(s.code,{children:"prepare(lat)"})," ",(0,r.jsx)(s.em,{children:"(optional)"})]}),"\n",(0,r.jsxs)(s.p,{children:["Called once when the physics process is added to the ",(0,r.jsx)(s.code,{children:"Navigator"}),"."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"lat"})," ",(0,r.jsx)(s.em,{children:"(MagneticLattice)"}),": The magnetic lattice used in the simulation."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Purpose:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"This method is optional, but can be overridden to perform setup operations such as trajectory calculation or initialization of diagnostic structures."}),"\n",(0,r.jsxs)(s.li,{children:["In the default implementation, it calls ",(0,r.jsx)(s.code,{children:"check_step()"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example Uses:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["In the ",(0,r.jsx)(s.a,{href:"/docs/docu/physics-processes/csr",children:"CSR process"}),", ",(0,r.jsx)(s.code,{children:"prepare()"})," is used to calculate the reference trajectory."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h3,{id:"applyp_array-dz-required",children:[(0,r.jsx)(s.code,{children:"apply(p_array, dz)"})," ",(0,r.jsx)(s.strong,{children:"(Required)"})]}),"\n",(0,r.jsx)(s.p,{children:"Called on every simulation step to apply the physics process to the particle array."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"p_array"})," ",(0,r.jsx)(s.em,{children:"(ParticleArray)"}),": The current particle distribution."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"dz"})," ",(0,r.jsx)(s.em,{children:"(float)"}),": Step size in meters."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note:"}),"\nThis method ",(0,r.jsx)(s.strong,{children:"must"})," be implemented in all subclasses."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.h3,{id:"finalizeargs-kwargs-optional",children:[(0,r.jsx)(s.code,{children:"finalize(*args, **kwargs)"})," ",(0,r.jsx)(s.em,{children:"(optional)"})]}),"\n",(0,r.jsx)(s.p,{children:"Called at the end of the simulation to perform any final operations, data collection, or cleanup."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"*args"}),": Additional positional arguments."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"**kwargs"}),": Additional keyword arguments."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example Uses:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["In ",(0,r.jsx)(s.a,{href:"/docs/docu/physics-processes/beam-analysis",children:"Beam Analysis"}),", ",(0,r.jsx)(s.code,{children:"finalize()"})," is used to store calculated beam diagnostics."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Customization:"}),(0,r.jsx)(s.br,{}),"\n","To implement a new physics process, subclass ",(0,r.jsx)(s.code,{children:"PhysProc"})," and override at least the ",(0,r.jsx)(s.code,{children:"apply()"})," method."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Validation:"}),(0,r.jsx)(s.br,{}),"\n","The ",(0,r.jsx)(s.code,{children:"check_step()"})," method ensures that step values are integers, preventing issues in lattice traversal."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Integration with Navigator:"}),(0,r.jsx)(s.br,{}),"\n","Attributes like ",(0,r.jsx)(s.code,{children:"indx0"}),", ",(0,r.jsx)(s.code,{children:"indx1"}),", ",(0,r.jsx)(s.code,{children:"s_start"}),", ",(0,r.jsx)(s.code,{children:"s_stop"}),", and ",(0,r.jsx)(s.code,{children:"z0"})," are automatically assigned when the process is added to a ",(0,r.jsx)(s.code,{children:"Navigator"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Optional lifecycle methods:"}),(0,r.jsx)(s.br,{}),"\n","Both ",(0,r.jsx)(s.code,{children:"prepare()"})," and ",(0,r.jsx)(s.code,{children:"finalize()"})," can be used for pre-tracking setup and post-tracking diagnostics, respectively."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"related-classes",children:"Related Classes"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/navigator",children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"Navigator"})})}),": Manages beam propagation and physics process execution."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/magnet-lattice",children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"MagneticLattice"})})}),": Defines the beamline and magnetic structure."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"ParticleArray"})})}),": Represents the state of the particle beam during simulation."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.p,{children:["For a practical example of using and customizing ",(0,r.jsx)(s.code,{children:"PhysProc"}),", see:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"/docs/docu/how-to/phys_proc",children:"How to Create Your Own Physics Process"})}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,c.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>l});var i=n(6540);const r={},c=i.createContext(r);function t(e){const s=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(c.Provider,{value:s},e.children)}}}]);