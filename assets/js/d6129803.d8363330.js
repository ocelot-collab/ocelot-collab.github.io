"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[8928],{193:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"docu/physics-processes/savebeam","title":"SaveBeam & CopyBeam","description":"A class to save the beam in arbitrary point of lattice","source":"@site/docs/docu/physics-processes/savebeam.md","sourceDirName":"docu/physics-processes","slug":"/docu/physics-processes/savebeam","permalink":"/docs/docu/physics-processes/savebeam","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/physics-processes/savebeam.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13,"title":"SaveBeam & CopyBeam","description":"A class to save the beam in arbitrary point of lattice"},"sidebar":"docsSidebar","previous":{"title":"Lattice Energy Profile","permalink":"/docs/docu/physics-processes/energy-profile"},"next":{"title":"How To","permalink":"/docs/category/how-to"}}');var r=s(4848),t=s(8453);const i={sidebar_position:13,title:"SaveBeam & CopyBeam",description:"A class to save the beam in arbitrary point of lattice"},o="SaveBeam and CopyBeam",l={},c=[{value:"SaveBeam",id:"savebeam",level:2},{value:"Purpose",id:"purpose",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Usage",id:"usage",level:3},{value:"CopyBeam",id:"copybeam",level:2},{value:"Purpose",id:"purpose-1",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Usage",id:"usage-1",level:3},{value:"Example Usage",id:"example-usage",level:2}];function p(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"savebeam-and-copybeam",children:"SaveBeam and CopyBeam"})}),"\n",(0,r.jsxs)(a.p,{children:["These two utility classes provide basic mechanisms for handling particle arrays within a beamline: saving and copying.\nThey are primarily used for diagnostics and debugging and are designed to be inserted into a beamline at specific positions (e.g., zero-length elements like ",(0,r.jsx)(a.code,{children:"Marker"})," instances)."]}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"savebeam",children:(0,r.jsx)(a.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/physics_proc.py#L85",children:"SaveBeam"})}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-python",children:'class SaveBeam(PhysProc):\n    def __init__(self, filename):\n        PhysProc.__init__(self)\n        self.energy = None\n        self.filename = filename\n\n    def apply(self, p_array, dz):\n        _logger.debug(" SaveBeam applied, dz =" + str(dz))\n        save_particle_array(filename=self.filename, p_array=p_array)\n        \n'})}),"\n",(0,r.jsx)(a.h3,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsx)(a.p,{children:"This physics process saves the state of the particle array to disk. It can be used for tracking diagnostics or to record beam parameters at a given location."}),"\n",(0,r.jsx)(a.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.code,{children:"filename"}),": Name of the file (with ",(0,r.jsx)(a.code,{children:".npz"})," extension) to which the particle array will be saved."]}),"\n"]}),"\n",(0,r.jsx)(a.h3,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(a.p,{children:["Typically attached to a ",(0,r.jsx)(a.code,{children:"Marker"})," element to save the particle distribution at a specific longitudinal position."]}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"copybeam",children:(0,r.jsx)(a.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/physics_proc.py#L102",children:"CopyBeam"})}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-python",children:'class CopyBeam(PhysProc):\n    """Physics process that copies the ParticleArray instance when applied."""\n    def __init__(self, name: str = ""):\n        super().__init__()\n        self.name = name\n        self.parray = None\n\n    def apply(self, parray: ParticleArray, dz: float) -> None:\n        """Copy the given particle array to self"""\n        self.parray = parray.copy()\n\n    def __repr__(self) -> str:\n        return f"<CopyBeam: {self.name}, at={hex(id(self))}>"\n'})}),"\n",(0,r.jsx)(a.h3,{id:"purpose-1",children:"Purpose"}),"\n",(0,r.jsxs)(a.p,{children:["This class stores an internal copy of the ",(0,r.jsx)(a.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,r.jsx)(a.code,{children:"ParticleArray"})})," when applied. It is useful for inspection or later comparison with other particle distributions during the simulation."]}),"\n",(0,r.jsxs)(a.p,{children:["In contrast to ",(0,r.jsx)(a.code,{children:"SaveBeam"}),", it does not save the data to disk but keeps it in memory."]}),"\n",(0,r.jsx)(a.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:[(0,r.jsx)(a.code,{children:"name"}),": Optional identifier for the copy (useful for debugging or visualization)."]}),"\n"]}),"\n",(0,r.jsx)(a.h3,{id:"usage-1",children:"Usage"}),"\n",(0,r.jsxs)(a.p,{children:["Attach ",(0,r.jsx)(a.code,{children:"CopyBeam"})," to a zero-length element (e.g., a ",(0,r.jsx)(a.code,{children:"Marker"}),") to snapshot the beam at a given point. This is especially useful when developing or validating beamline physics processes."]}),"\n",(0,r.jsx)(a.hr,{}),"\n",(0,r.jsx)(a.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(a.p,{children:"These processes will record the beam at positions 10 and 20 in the lattice, respectively:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-python",children:'from ocelot import *\n\n# Define basic lattice elements\nd = Drift(l=1)        # 1-meter drift space\nm1 = Marker()         # Marker where we will save the beam\nm2 = Marker()         # Marker where we will copy the beam\n\n# Construct a simple beamline: Drift -> Marker -> Drift -> Marker\nlat = MagneticLattice([d, m1, d, m2])\n\n# Create physics processes\nsb = SaveBeam(filename="m1.npz")  # Will save the particle array at m1 to file\ncb = CopyBeam()                   # Will copy the particle array at m2 into memory\n\n# Create a Navigator to manage physics processes during tracking\nnavi = Navigator(lat)\n\n# Attach the physics processes to specific elements\nnavi.add_physics_proc(sb, m1, m1)  # Apply SaveBeam at m1\nnavi.add_physics_proc(cb, m2, m2)  # Apply CopyBeam at m2\n\n# Generate a test particle array\nparray = generate_parray(nparticles=10000)\n\n# Track the particle array through the lattice with the navigator\ntrack(lat, parray, navi)\n\n# Load and print the saved particle array from file\nparray_m1 = load_particle_array("m1.npz")\nprint(parray_m1)\n\n# Print the copied particle array from memory (after m2)\nprint(cb.parray)\n'})}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-python",children:"    z = 2.0 / 2.0. Applied: CopyBeamParticleArray: \n    Ref. energy : 0.13 GeV \n    Ave. energy : 0.13 GeV \n    std(x)      : 0.102 mm\n    std(px)     : 0.02 mrad\n    std(y)      : 0.102 mm\n    std(py)     : 0.02 mrad\n    std(p)      : 0.0099\n    std(tau)    : 0.993 mm\n    Charge      : 5.0 nC \n    s pos       : 1.0 m \n    n particles : 10000\n    \n    ParticleArray: \n    Ref. energy : 0.13 GeV \n    Ave. energy : 0.13 GeV \n    std(x)      : 0.108 mm\n    std(px)     : 0.02 mrad\n    std(y)      : 0.108 mm\n    std(py)     : 0.02 mrad\n    std(p)      : 0.0099\n    std(tau)    : 0.993 mm\n    Charge      : 5.0 nC \n    s pos       : 2.0 m \n    n particles : 10000\n"})})]})}function d(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,a,s)=>{s.d(a,{R:()=>i,x:()=>o});var n=s(6540);const r={},t=n.createContext(r);function i(e){const a=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(t.Provider,{value:a},e.children)}}}]);