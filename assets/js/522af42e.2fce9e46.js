"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[2080],{8802:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"docu/OCELOT fundamentals/navigator","title":"Navigator","description":"Description","source":"@site/docs/docu/OCELOT fundamentals/navigator.md","sourceDirName":"docu/OCELOT fundamentals","slug":"/docu/OCELOT fundamentals/navigator","permalink":"/docs/docu/OCELOT fundamentals/navigator","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot/docs/docu/OCELOT fundamentals/navigator.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Navigator"},"sidebar":"docsSidebar","previous":{"title":"MagneticLattice","permalink":"/docs/docu/OCELOT fundamentals/magnet-lattice"},"next":{"title":"Tracking Functions","permalink":"/docs/docu/OCELOT fundamentals/tracking"}}');var l=n(4848),r=n(8453);const i={sidebar_position:6,title:"Navigator"},c="Navigator Class",d={},o=[{value:"Description",id:"description",level:2},{value:"Constructor",id:"constructor",level:2},{value:"<code>__init__(self, lattice, unit_step=1)</code>",id:"__init__self-lattice-unit_step1",level:3},{value:"Arguments:",id:"arguments",level:4},{value:"Methods",id:"methods",level:2},{value:"<code>get_current_element(self)</code>",id:"get_current_elementself",level:3},{value:"Returns:",id:"returns",level:4},{value:"<code>reset_position(self)</code>",id:"reset_positionself",level:3},{value:"<code>go_to_start(self)</code>",id:"go_to_startself",level:3},{value:"<code>get_phys_procs(self)</code>",id:"get_phys_procsself",level:3},{value:"Returns:",id:"returns-1",level:4},{value:"<code>add_physics_proc(self, physics_proc, elem1, elem2)</code>",id:"add_physics_procself-physics_proc-elem1-elem2",level:3},{value:"Arguments:",id:"arguments-1",level:4},{value:"Returns:",id:"returns-2",level:4},{value:"<code>add_physics_processes(self, processes, elem1s, elem2s)</code>",id:"add_physics_processesself-processes-elem1s-elem2s",level:3},{value:"Arguments:",id:"arguments-2",level:4},{value:"Returns:",id:"returns-3",level:4},{value:"<code>activate_apertures(self, start=None, stop=None)</code>",id:"activate_aperturesself-startnone-stopnone",level:3},{value:"Arguments:",id:"arguments-3",level:4},{value:"Returns:",id:"returns-4",level:4},{value:"<code>check_overjump(self, dz, processes, phys_steps)</code>",id:"check_overjumpself-dz-processes-phys_steps",level:3},{value:"Arguments:",id:"arguments-4",level:4},{value:"Returns:",id:"returns-5",level:4},{value:"<code>get_proc_list(self)</code>",id:"get_proc_listself",level:3},{value:"Returns:",id:"returns-6",level:4},{value:"<code>hard_edge_step(self, dz)</code>",id:"hard_edge_stepself-dz",level:3},{value:"Arguments:",id:"arguments-5",level:4},{value:"Returns:",id:"returns-7",level:4},{value:"<code>check_proc_bounds(self, dz, proc_list, phys_steps, active_process)</code>",id:"check_proc_boundsself-dz-proc_list-phys_steps-active_process",level:3},{value:"Arguments:",id:"arguments-6",level:4},{value:"Returns:",id:"returns-8",level:4},{value:"<code>remove_used_processes(self, processes)</code>",id:"remove_used_processesself-processes",level:3},{value:"Arguments:",id:"arguments-7",level:4},{value:"Returns:",id:"returns-9",level:4},{value:"<code>jump_to(self, z: float)</code>",id:"jump_toself-z-float",level:3},{value:"Arguments:",id:"arguments-8",level:4},{value:"Returns:",id:"returns-10",level:4},{value:"<code>get_next_step(self)</code>",id:"get_next_stepself",level:3},{value:"Returns:",id:"returns-11",level:4},{value:"<code>get_next(self)</code>",id:"get_nextself",level:3},{value:"Returns:",id:"returns-12",level:4},{value:"<code>__str__(self)</code>",id:"__str__self",level:3},{value:"Returns:",id:"returns-13",level:4},{value:"<code>get_map(self, dz)</code>",id:"get_mapself-dz",level:3},{value:"Arguments:",id:"arguments-9",level:4},{value:"Returns:",id:"returns-14",level:4},{value:"<code>_update_references(self)</code>",id:"_update_referencesself",level:3},{value:"Returns:",id:"returns-15",level:4}];function h(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.header,{children:(0,l.jsx)(s.h1,{id:"navigator-class",children:"Navigator Class"})}),"\n",(0,l.jsx)(s.h2,{id:"description",children:"Description"}),"\n",(0,l.jsxs)(s.p,{children:["The ",(0,l.jsx)(s.code,{children:"Navigator"})," class defines the step size (dz) for tracking and specifies which physical processes will be applied during each step. It interacts with a ",(0,l.jsx)(s.code,{children:"MagneticLattice"})," and manages the tracking of particles through the lattice, updating the position and applying relevant physics processes as particles travel."]}),"\n",(0,l.jsx)(s.h2,{id:"constructor",children:"Constructor"}),"\n",(0,l.jsx)(s.h3,{id:"__init__self-lattice-unit_step1",children:(0,l.jsx)(s.code,{children:"__init__(self, lattice, unit_step=1)"})}),"\n",(0,l.jsx)(s.h4,{id:"arguments",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"lattice"})," (",(0,l.jsx)(s.code,{children:"MagneticLattice"}),"): The magnetic lattice to which the navigator is applied."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"unit_step"})," (",(0,l.jsx)(s.code,{children:"float"}),", optional): The unit step size for all physics processes. Default is 1 meter."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,l.jsx)(s.h3,{id:"get_current_elementself",children:(0,l.jsx)(s.code,{children:"get_current_element(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Returns the current element in the lattice at the position of the navigator."}),"\n",(0,l.jsx)(s.h4,{id:"returns",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"The current element in the lattice."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"reset_positionself",children:(0,l.jsx)(s.code,{children:"reset_position(self)"})}),"\n",(0,l.jsxs)(s.p,{children:["Resets the position of the navigator, setting the current position (",(0,l.jsx)(s.code,{children:"z0"}),") to 0, the current index (",(0,l.jsx)(s.code,{children:"n_elem"}),") to 0, and the sum of lengths to 0."]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"go_to_startself",children:(0,l.jsx)(s.code,{children:"go_to_start(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Resets the navigator to the starting position."}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"get_phys_procsself",children:(0,l.jsx)(s.code,{children:"get_phys_procs(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Returns the list of all physics processes that have been added to the navigator."}),"\n",(0,l.jsx)(s.h4,{id:"returns-1",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A list of physical processes."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"add_physics_procself-physics_proc-elem1-elem2",children:(0,l.jsx)(s.code,{children:"add_physics_proc(self, physics_proc, elem1, elem2)"})}),"\n",(0,l.jsx)(s.p,{children:"Adds a physical process to be applied between two elements in the lattice."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-1",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"physics_proc"})," (",(0,l.jsx)(s.code,{children:"PhysProc"}),"): The physical process to be applied, e.g., SpaceCharge, CSR, Wake, etc."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"elem1"})," (",(0,l.jsx)(s.code,{children:"Element"}),"): The element where the physical process begins."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"elem2"})," (",(0,l.jsx)(s.code,{children:"Element"}),"): The element where the physical process ends."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-2",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"None"}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"add_physics_processesself-processes-elem1s-elem2s",children:(0,l.jsx)(s.code,{children:"add_physics_processes(self, processes, elem1s, elem2s)"})}),"\n",(0,l.jsx)(s.p,{children:"Adds multiple physical processes to be applied between corresponding pairs of elements in the lattice."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-2",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"processes"})," (",(0,l.jsx)(s.code,{children:"list"}),"): A list of physical processes to be applied."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"elem1s"})," (",(0,l.jsx)(s.code,{children:"list"}),"): A list of elements where each process starts."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"elem2s"})," (",(0,l.jsx)(s.code,{children:"list"}),"): A list of elements where each process ends."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-3",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"None"}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"activate_aperturesself-startnone-stopnone",children:(0,l.jsx)(s.code,{children:"activate_apertures(self, start=None, stop=None)"})}),"\n",(0,l.jsx)(s.p,{children:"Activates apertures in the lattice between specified elements."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-3",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"start"})," (",(0,l.jsx)(s.code,{children:"Element"}),", optional): The element to start from."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"stop"})," (",(0,l.jsx)(s.code,{children:"Element"}),", optional): The element to stop at."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-4",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"None"}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"check_overjumpself-dz-processes-phys_steps",children:(0,l.jsx)(s.code,{children:"check_overjump(self, dz, processes, phys_steps)"})}),"\n",(0,l.jsxs)(s.p,{children:["Checks if the current step ",(0,l.jsx)(s.code,{children:"dz"})," causes an overjump of the physical processes and adjusts the step accordingly."]}),"\n",(0,l.jsx)(s.h4,{id:"arguments-4",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"dz"})," (",(0,l.jsx)(s.code,{children:"float"}),"): The step size to be checked."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"processes"})," (",(0,l.jsx)(s.code,{children:"list"}),"): The list of processes to check."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"phys_steps"})," (",(0,l.jsx)(s.code,{children:"list"}),"): The list of physical steps taken."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-5",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["The adjusted step size ",(0,l.jsx)(s.code,{children:"dz"}),", the list of processes, and the list of physical steps."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"get_proc_listself",children:(0,l.jsx)(s.code,{children:"get_proc_list(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Returns the list of all physical processes that are relevant to the current position of the navigator."}),"\n",(0,l.jsx)(s.h4,{id:"returns-6",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A list of relevant physical processes."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"hard_edge_stepself-dz",children:(0,l.jsx)(s.code,{children:"hard_edge_step(self, dz)"})}),"\n",(0,l.jsxs)(s.p,{children:["Checks if the current step ",(0,l.jsx)(s.code,{children:"dz"})," exceeds the length of the current element and adjusts it accordingly."]}),"\n",(0,l.jsx)(s.h4,{id:"arguments-5",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"dz"})," (",(0,l.jsx)(s.code,{children:"float"}),"): The step size to be checked."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-7",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["The adjusted step size ",(0,l.jsx)(s.code,{children:"dz"}),"."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"check_proc_boundsself-dz-proc_list-phys_steps-active_process",children:(0,l.jsx)(s.code,{children:"check_proc_bounds(self, dz, proc_list, phys_steps, active_process)"})}),"\n",(0,l.jsxs)(s.p,{children:["Checks if the step size ",(0,l.jsx)(s.code,{children:"dz"})," exceeds the bounds of the physical processes and adjusts the list of active processes."]}),"\n",(0,l.jsx)(s.h4,{id:"arguments-6",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"dz"})," (",(0,l.jsx)(s.code,{children:"float"}),"): The step size."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"proc_list"})," (",(0,l.jsx)(s.code,{children:"list"}),"): The list of all processes."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"phys_steps"})," (",(0,l.jsx)(s.code,{children:"list"}),"): The list of physical steps."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"active_process"})," (",(0,l.jsx)(s.code,{children:"list"}),"): The list of active processes."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-8",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"The updated list of active processes and physical steps."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"remove_used_processesself-processes",children:(0,l.jsx)(s.code,{children:"remove_used_processes(self, processes)"})}),"\n",(0,l.jsx)(s.p,{children:"Removes processes that have been applied from the list of active processes and moves them to the inactive processes list."}),"\n",(0,l.jsx)(s.h4,{id:"arguments-7",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"processes"})," (",(0,l.jsx)(s.code,{children:"list"}),"): The list of processes to be removed."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-9",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"None"}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"jump_toself-z-float",children:(0,l.jsx)(s.code,{children:"jump_to(self, z: float)"})}),"\n",(0,l.jsxs)(s.p,{children:["Sets the current position of the navigator to a new position ",(0,l.jsx)(s.code,{children:"z"}),"."]}),"\n",(0,l.jsx)(s.h4,{id:"arguments-8",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"z"})," (",(0,l.jsx)(s.code,{children:"float"}),"): The position to jump to."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-10",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"None"}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"get_next_stepself",children:(0,l.jsx)(s.code,{children:"get_next_step(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Yields the next step of the tracking, applying the relevant physical processes as needed."}),"\n",(0,l.jsx)(s.h4,{id:"returns-11",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["A generator that yields the next step, including the map of the tracking, the step size ",(0,l.jsx)(s.code,{children:"dz"}),", the processes to be applied, and the physical steps."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"get_nextself",children:(0,l.jsx)(s.code,{children:"get_next(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Gets the next step of the tracking, checking for physical processes to apply and adjusting the step size accordingly."}),"\n",(0,l.jsx)(s.h4,{id:"returns-12",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["The step size ",(0,l.jsx)(s.code,{children:"dz"}),", the list of processes to apply, and the list of physical steps."]}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"__str__self",children:(0,l.jsx)(s.code,{children:"__str__(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Returns a string representation of the navigator, including details of all the added physical processes."}),"\n",(0,l.jsx)(s.h4,{id:"returns-13",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A string containing information about the added physical processes."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"get_mapself-dz",children:(0,l.jsx)(s.code,{children:"get_map(self, dz)"})}),"\n",(0,l.jsxs)(s.p,{children:["Gets the transfer map for a given step size ",(0,l.jsx)(s.code,{children:"dz"})," based on the lattice sequence."]}),"\n",(0,l.jsx)(s.h4,{id:"arguments-9",children:"Arguments:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"dz"})," (",(0,l.jsx)(s.code,{children:"float"}),"): The step size."]}),"\n"]}),"\n",(0,l.jsx)(s.h4,{id:"returns-14",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"A list of transfer maps for the given step size."}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h3,{id:"_update_referencesself",children:(0,l.jsx)(s.code,{children:"_update_references(self)"})}),"\n",(0,l.jsx)(s.p,{children:"Updates the references of the process table and the processes to ensure consistency across all elements in the lattice."}),"\n",(0,l.jsx)(s.h4,{id:"returns-15",children:"Returns:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"None"}),"\n"]})]})}function a(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,l.jsx)(s,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>c});var t=n(6540);const l={},r=t.createContext(l);function i(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);