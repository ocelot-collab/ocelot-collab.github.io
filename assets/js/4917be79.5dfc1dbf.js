"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[7597],{5751:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"docu/OCELOT fundamentals/magnet-lattice","title":"MagneticLattice","description":"MagneticLattice class","source":"@site/docs/docu/OCELOT fundamentals/magnet-lattice.md","sourceDirName":"docu/OCELOT fundamentals","slug":"/docu/OCELOT fundamentals/magnet-lattice","permalink":"/docs/docu/OCELOT fundamentals/magnet-lattice","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/OCELOT fundamentals/magnet-lattice.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"MagneticLattice","description":"MagneticLattice class"},"sidebar":"docsSidebar","previous":{"title":"Intro to OCELOT Structure","permalink":"/docs/docu/OCELOT fundamentals/intro"},"next":{"title":"Navigator","permalink":"/docs/docu/OCELOT fundamentals/navigator"}}');var l=s(4848),i=s(8453);const r={sidebar_position:5,title:"MagneticLattice",description:"MagneticLattice class"},c="MagneticLattice Class",d={},o=[{value:"Description",id:"description",level:2},{value:"Simplest Example of Use",id:"simplest-example-of-use",level:3},{value:"Constructor",id:"constructor",level:2},{value:"Arguments:",id:"arguments",level:4},{value:"Methods",id:"methods",level:2},{value:"<code>get_sequence_part(self, start: E, stop: E)</code>",id:"get_sequence_partself-start-e-stop-e",level:4},{value:"Arguments:",id:"arguments-1",level:4},{value:"Returns:",id:"returns",level:4},{value:"<code>update_transfer_maps(self)</code>",id:"update_transfer_mapsself",level:3},{value:"Returns:",id:"returns-1",level:4},{value:"<code>__str__(self)</code>",id:"__str__self",level:4},{value:"Returns:",id:"returns-2",level:4},{value:"<code>find_indices(self, element)</code>",id:"find_indicesself-element",level:4},{value:"Arguments:",id:"arguments-2",level:4},{value:"Returns:",id:"returns-3",level:4},{value:"<code>find_drifts(self)</code>",id:"find_driftsself",level:4},{value:"Returns:",id:"returns-4",level:4},{value:"<code>rem_drifts(self)</code>",id:"rem_driftsself",level:4},{value:"<code>save_as_py_file(self, file_name: str, tws0=None, remove_rep_drifts=True, power_supply=False)</code>",id:"save_as_py_fileself-file_name-str-tws0none-remove_rep_driftstrue-power_supplyfalse",level:4},{value:"Arguments:",id:"arguments-3",level:4},{value:"<code>transfer_maps(self, energy, output_at_each_step: bool = False, start: E = None, stop: E = None)</code>",id:"transfer_mapsself-energy-output_at_each_step-bool--false-start-e--none-stop-e--none",level:4},{value:"Arguments:",id:"arguments-4",level:4},{value:"Returns:",id:"returns-5",level:4},{value:"<code>survey(self, x0=0, y0=0, z0=0, ang_x=0.0, ang_y=0.0)</code>",id:"surveyself-x00-y00-z00-ang_x00-ang_y00",level:4},{value:"Arguments:",id:"arguments-5",level:4},{value:"Returns:",id:"returns-6",level:4},{value:"<code>print_sequence(self, start: E = None, stop: E = None)</code>",id:"print_sequenceself-start-e--none-stop-e--none",level:4},{value:"Arguments:",id:"arguments-6",level:4},{value:"Returns:",id:"returns-7",level:4},{value:"<code>periodic_twiss(self, tws=None)</code>",id:"periodic_twissself-twsnone",level:4},{value:"Arguments:",id:"arguments-7",level:4},{value:"Returns:",id:"returns-8",level:4}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsxs)(n.h1,{id:"magneticlattice-class",children:[(0,l.jsx)(n.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/magnetic_lattice.py#L163",children:"MagneticLattice"})," Class"]})}),"\n",(0,l.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/magnetic_lattice.py#L163",children:(0,l.jsx)(n.code,{children:"MagneticLattice"})})," class\nrepresents a magnetic lattice, which is a sequence of elements forming a beamline. The lattice elements can include magnets,\nquadrupoles, undulators, and drifts, and they are used to model the trajectory and dynamics of a particle beam.\nThis class allows for various operations like updating transfer maps, calculating lattice length, and finding specific\nelements within the lattice. It also provides functionality for calculating transfer maps and periodic Twiss parameters."]}),"\n",(0,l.jsx)(n.h3,{id:"simplest-example-of-use",children:"Simplest Example of Use"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from ocelot import *\n# Create elements of beamline\nd = Drift(l=1)\nq = Quadrupole(l=1, k1=1)\n\n# Create your beamline - sequence of elements\ncell = (d, q)\n\nlat = MagneticLattice(cell)\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"class MagneticLattice:\n    def __init__(self, sequence, start: E = None, stop: E = None, method=None):\n        ...\n"})}),"\n",(0,l.jsx)(n.h4,{id:"arguments",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"sequence"})," (",(0,l.jsx)(n.code,{children:"list"}),"): A list of elements that form the lattice."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"start"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),", optional): The first element of the lattice. If ",(0,l.jsx)(n.code,{children:"None"}),", the lattice starts with the first element of the sequence."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"stop"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),", optional): The last element of the lattice (included). If ",(0,l.jsx)(n.code,{children:"None"}),", the lattice stops with the last element of the sequence."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"method"})," (",(0,l.jsx)(n.code,{children:"dict"}),", optional): A dictionary specifying the tracking method for the lattice. If no method is provided,\n",(0,l.jsx)(n.a,{href:"/docs/docu/trasfer-maps/first-order",children:(0,l.jsx)(n.code,{children:"TransferMap"})})," is used as the global default for all elements.\nSpecific methods for individual elements can also be set."]}),"\n",(0,l.jsx)(n.p,{children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'method = {"global": TransferMap} # default first order transfer map\nlat = MagneticLattice(cell, method=method)\n# or\nmethod = {"global": SecondTM, Octupole: KickTM, Undulator: RungeKuttaTM}\nlat = MagneticLattice(cell, method=method)\n'})}),"\n",(0,l.jsx)(n.p,{children:"In this example:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Sets ",(0,l.jsx)(n.a,{href:"/docs/docu/trasfer-maps/second-order",children:(0,l.jsx)(n.code,{children:"SecondTM"})})," (second order transfer maps) as the global transfer map for all elements."]}),"\n",(0,l.jsxs)(n.li,{children:["Assigns ",(0,l.jsx)(n.code,{children:"KickTM"})," specifically for ",(0,l.jsx)(n.code,{children:"Octupole"})," elements."]}),"\n",(0,l.jsxs)(n.li,{children:["Assigns ",(0,l.jsx)(n.code,{children:"RungeKuttaTM"})," specifically for ",(0,l.jsx)(n.code,{children:"Undulator"})," elements."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.admonition,{type:"info",children:[(0,l.jsxs)(n.p,{children:["In order to avoid mistakes, the ",(0,l.jsx)(n.strong,{children:"start"})," and ",(0,l.jsx)(n.strong,{children:"stop"})," element must be different objects.\nIt is also recommended to use the Marker element as both the ",(0,l.jsx)(n.strong,{children:"start"})," and ",(0,l.jsx)(n.strong,{children:"stop"})," element."]}),(0,l.jsx)(n.p,{children:"Example:"}),(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'m1 = Marker()\nm2 = Marker()\ncell = [m1, d, q, ... , m2, d10, qf10, ...]\nlat = MagneticLattice(cell, start=m1, stop=m2, method={"global": SecondTM})\n'})})]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,l.jsx)(n.h4,{id:"get_sequence_partself-start-e-stop-e",children:(0,l.jsx)(n.code,{children:"get_sequence_part(self, start: E, stop: E)"})}),"\n",(0,l.jsxs)(n.p,{children:["This method gets a part of the lattice sequence starting from ",(0,l.jsx)(n.code,{children:"start"})," to ",(0,l.jsx)(n.code,{children:"stop"}),"."]}),"\n",(0,l.jsx)(n.h4,{id:"arguments-1",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"start"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),"): The element where the sequence starts."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"stop"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),"): The element where the sequence ends (included ",(0,l.jsx)(n.strong,{children:"stop"})," element)."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"returns",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"A sublist of elements from the sequence."}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"update_transfer_mapsself",children:(0,l.jsx)(n.code,{children:"update_transfer_maps(self)"})}),"\n",(0,l.jsxs)(n.p,{children:["The name of the method does not accurately reflect its functionality but is retained for legacy purposes.\nThis method assigns specific transfer maps to each element in the sequence based on a ",(0,l.jsx)(n.code,{children:"method"})," dictionary.\nAdditionally, it calculates the total length ",(0,l.jsx)(n.code,{children:"self.totalLen"})," of the lattice by summing the lengths of its elements."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"for i, element in enumerate(self.sequence):\n    self.totalLen += element.l  # Accumulate the total length of the lattice\n    tm_class_type = self.method.get(element.__class__)  # Get specific transfer map for element class\n    if tm_class_type:\n        element.set_tm(tm_class_type)  # Set the class-specific transfer map\n    else:\n        tm_class_type = self.method.get('global')  # Fallback to the global transfer map\n        if tm_class_type:\n            element.set_tm(tm_class_type)  # Set the global transfer map\n"})}),"\n",(0,l.jsx)(n.h4,{id:"returns-1",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The updated ",(0,l.jsx)(n.code,{children:"MagneticLattice"})," object."]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"__str__self",children:(0,l.jsx)(n.code,{children:"__str__(self)"})}),"\n",(0,l.jsx)(n.p,{children:"Returns a string representation of the lattice, showing the total length and details of each element."}),"\n",(0,l.jsx)(n.h4,{id:"returns-2",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"A string containing the total length and details of each element in the sequence."}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"find_indicesself-element",children:(0,l.jsx)(n.code,{children:"find_indices(self, element)"})}),"\n",(0,l.jsx)(n.p,{children:"Finds the indices of elements in the sequence by their class type."}),"\n",(0,l.jsx)(n.h4,{id:"arguments-2",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"element"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),"): The class type of the element to search for."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"returns-3",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"A list of indices where the specified element type is found in the sequence."}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"find_driftsself",children:(0,l.jsx)(n.code,{children:"find_drifts(self)"})}),"\n",(0,l.jsx)(n.p,{children:"Finds the drift elements in the sequence and returns them."}),"\n",(0,l.jsx)(n.h4,{id:"returns-4",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"A list of drift elements."}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"rem_driftsself",children:(0,l.jsx)(n.code,{children:"rem_drifts(self)"})}),"\n",(0,l.jsx)(n.p,{children:"Removes repeated drift elements from the lattice."}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"save_as_py_fileself-file_name-str-tws0none-remove_rep_driftstrue-power_supplyfalse",children:(0,l.jsx)(n.code,{children:"save_as_py_file(self, file_name: str, tws0=None, remove_rep_drifts=True, power_supply=False)"})}),"\n",(0,l.jsx)(n.p,{children:"Saves the lattice to a Python file."}),"\n",(0,l.jsx)(n.h4,{id:"arguments-3",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"file_name"})," (",(0,l.jsx)(n.code,{children:"str"}),"): The path and name of the Python file where the lattice will be stored."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"tws0"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,l.jsx)(n.code,{children:"Twiss"})}),", optional): A ",(0,l.jsx)(n.code,{children:"Twiss"})," object. If provided, the Twiss parameters will be printed at the beginning of the lattice file."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"remove_rep_drifts"})," (",(0,l.jsx)(n.code,{children:"bool"}),", optional): If ",(0,l.jsx)(n.code,{children:"True"}),", removes repeated drift elements from the lattice."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"power_supply"})," (",(0,l.jsx)(n.code,{children:"bool"}),", optional): If ",(0,l.jsx)(n.code,{children:"True"}),", writes the power supply IDs into the file."]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"transfer_mapsself-energy-output_at_each_step-bool--false-start-e--none-stop-e--none",children:(0,l.jsx)(n.code,{children:"transfer_maps(self, energy, output_at_each_step: bool = False, start: E = None, stop: E = None)"})}),"\n",(0,l.jsx)(n.p,{children:"Calculates the transfer maps (first and second orders) for the entire lattice."}),"\n",(0,l.jsx)(n.h4,{id:"arguments-4",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"energy"})," (",(0,l.jsx)(n.code,{children:"float"}),"): The initial electron beam energy in GeV."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"output_at_each_step"})," (",(0,l.jsx)(n.code,{children:"bool"}),", optional): If ",(0,l.jsx)(n.code,{children:"True"}),", returns the transfer maps at each step in the lattice."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"start"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),", optional): The element to start from in the sequence."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"stop"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),", optional): The element to stop at in the sequence."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"returns-5",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["The transfer maps (",(0,l.jsx)(n.code,{children:"B"}),", ",(0,l.jsx)(n.code,{children:"R"}),", ",(0,l.jsx)(n.code,{children:"T"}),") for the entire lattice or at each step if ",(0,l.jsx)(n.code,{children:"output_at_each_step"})," is ",(0,l.jsx)(n.code,{children:"True"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"surveyself-x00-y00-z00-ang_x00-ang_y00",children:(0,l.jsx)(n.code,{children:"survey(self, x0=0, y0=0, z0=0, ang_x=0.0, ang_y=0.0)"})}),"\n",(0,l.jsx)(n.p,{children:"Calculates coordinates in rectangular coordinates at the beginning of each element in the lattice."}),"\n",(0,l.jsx)(n.h4,{id:"arguments-5",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"x0"})," (",(0,l.jsx)(n.code,{children:"float"}),", optional): The initial offset in the x direction."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"y0"})," (",(0,l.jsx)(n.code,{children:"float"}),", optional): The initial offset in the y direction."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"z0"})," (",(0,l.jsx)(n.code,{children:"float"}),", optional): The initial offset in the z direction."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ang_x"})," (",(0,l.jsx)(n.code,{children:"float"}),", optional): The initial angle in the horizontal plane."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ang_y"})," (",(0,l.jsx)(n.code,{children:"float"}),", optional): The initial angle in the vertical plane."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"returns-6",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Lists of coordinates: ",(0,l.jsx)(n.code,{children:"x"}),", ",(0,l.jsx)(n.code,{children:"y"}),", ",(0,l.jsx)(n.code,{children:"z"}),", ",(0,l.jsx)(n.code,{children:"a_x"}),", ",(0,l.jsx)(n.code,{children:"a_y"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"print_sequenceself-start-e--none-stop-e--none",children:(0,l.jsx)(n.code,{children:"print_sequence(self, start: E = None, stop: E = None)"})}),"\n",(0,l.jsx)(n.p,{children:"Prints the sequence of elements in the lattice, including their lengths and start/end positions."}),"\n",(0,l.jsx)(n.h4,{id:"arguments-6",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"start"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),", optional): The element to start from in the sequence."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"stop"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/elements/element",children:(0,l.jsx)(n.code,{children:"Element"})}),", optional): The element to stop at in the sequence."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"returns-7",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"A list of strings representing the sequence of elements."}),"\n"]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h4,{id:"periodic_twissself-twsnone",children:(0,l.jsx)(n.code,{children:"periodic_twiss(self, tws=None)"})}),"\n",(0,l.jsx)(n.p,{children:"Calculates the periodic Twiss parameters for the lattice using transfer maps."}),"\n",(0,l.jsx)(n.h4,{id:"arguments-7",children:"Arguments:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"tws"})," (",(0,l.jsx)(n.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,l.jsx)(n.code,{children:"Twiss"})}),", optional): A ",(0,l.jsx)(n.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:(0,l.jsx)(n.code,{children:"Twiss"})})," object. If provided, the initial Twiss parameters will be used."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"returns-8",children:"Returns:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The periodic Twiss parameters."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(6540);const l={},i=t.createContext(l);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);