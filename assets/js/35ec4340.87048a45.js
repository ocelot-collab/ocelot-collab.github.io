"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[2232],{1886:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"docu/OCELOT fundamentals/matching","title":"Matching","description":"Matching functions","source":"@site/docs/docu/OCELOT fundamentals/matching.md","sourceDirName":"docu/OCELOT fundamentals","slug":"/docu/OCELOT fundamentals/matching","permalink":"/docs/docu/OCELOT fundamentals/matching","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/OCELOT fundamentals/matching.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Matching","description":"Matching functions"},"sidebar":"docsSidebar","previous":{"title":"Twiss","permalink":"/docs/docu/OCELOT fundamentals/twiss"},"next":{"title":"Elements","permalink":"/docs/category/elements"}}');var t=s(4848),l=s(8453);const r={sidebar_position:10,title:"Matching",description:"Matching functions"},c="match Function",a={},o=[{value:"Overview",id:"overview",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Required Parameters",id:"required-parameters",level:3},{value:"Optional Parameters",id:"optional-parameters",level:3},{value:"Returns",id:"returns",level:2},{value:"Example Usage",id:"example-usage",level:2},{value:"Basic Matching",id:"basic-matching",level:3},{value:"Matching with Global and Soft Constraints",id:"matching-with-global-and-soft-constraints",level:2},{value:"Notes",id:"notes",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsxs)(n.h1,{id:"match-function",children:[(0,t.jsx)(n.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/match.py#L42",children:(0,t.jsx)(n.code,{children:"match"})})," Function"]})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/match.py#L42",children:(0,t.jsx)(n.code,{children:"match"})})," function in Ocelot is designed to match Twiss parameters in a magnetic lattice by optimizing a set of variables.\nIt supports constraints for periodic solutions, beam optics matching, and specific goals like minimizing radiation integrals. The function allows customization of the optimization process using various methods, tolerances, and weights."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsx)(n.h3,{id:"required-parameters",children:"Required Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"lat"})})," ",(0,t.jsxs)(n.a,{href:"/docs/docu/OCELOT%20fundamentals/magnet-lattice",children:["(",(0,t.jsx)(n.code,{children:"MagneticLattice"}),")"]}),": The magnetic lattice object to be optimized."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"constr"})})," (",(0,t.jsx)(n.code,{children:"dict"}),"): A dictionary of constraints. Examples:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Periodic solution"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"constr = {'periodic': True}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:'"Hard" constraints at specific elements'}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"constr = {elem1: {'beta_x': 15, 'beta_y': 2}, elem2: {'Dx': 0, 'Dyp': 0}}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:'Combination of "soft" and "hard" constraints'}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"constr = {elem1: {'alpha_x': ['>', 5], 'beta_y': 5}, elem2: {'Dx': 0, 'beta_x': ['<', 10]}}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Absolute value constraints"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"constr = {elem1: {'alpha_x': ['a>', 5], 'alpha_y': ['a<', 1]}}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Global constraints"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"constr = {'global': {'beta_x': ['>', 10]}}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Experimental constraints"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'constr = {"delta": {ELEM1: ["muy", 0], ELEM2: ["muy", 0], "val": 3*np.pi/2, "weight": 100007}}\n'})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"vars"})})," (",(0,t.jsx)(n.code,{children:"list"}),"): List of variables to optimize. Examples:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Beamline elements:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"vars = [QF, QD]\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Initial Twiss parameters:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"vars = [[tws0, 'beta_x'], [tws0, 'beta_y']]\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"tw"})})," ",(0,t.jsxs)(n.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:["(",(0,t.jsx)(n.code,{children:"Twiss"}),")"]}),": Initial Twiss parameters."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"optional-parameters",children:"Optional Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"verbose"})})," (",(0,t.jsx)(n.code,{children:"bool"}),"): Enables verbose output during the optimization. Default is ",(0,t.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"max_iter"})})," (",(0,t.jsx)(n.code,{children:"int"}),"): Maximum number of iterations for the optimization process. Default is ",(0,t.jsx)(n.code,{children:"1000"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"method"})})," (",(0,t.jsx)(n.code,{children:"str"}),"): Optimization method. Options:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'simplex'"})," (default)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'cg'"})," (Conjugate Gradient)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'bfgs'"})," (Broyden\u2013Fletcher\u2013Goldfarb\u2013Shanno)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"weights"})})," (",(0,t.jsx)(n.code,{children:"function"}),"): Function to assign weights to constraints. Default is ",(0,t.jsx)(n.code,{children:"weights_default"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"vary_bend_angle"})})," (",(0,t.jsx)(n.code,{children:"bool"}),"): Allows varying the bending angle of dipoles instead of their focusing strength ",(0,t.jsx)(n.code,{children:"k1"}),". Default is ",(0,t.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"min_i5"})})," (",(0,t.jsx)(n.code,{children:"bool"}),"): Minimizes the radiation integral ",(0,t.jsx)(n.code,{children:"I5"}),". Useful for storage ring optimization. Default is ",(0,t.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"tol"})})," (",(0,t.jsx)(n.code,{children:"float"}),"): Tolerance for the optimization process. Default is ",(0,t.jsx)(n.code,{children:"1e-5"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"res"})}),": The optimization result, which includes the optimized values for the specified variables."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,t.jsx)(n.h3,{id:"basic-matching",children:"Basic Matching"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from ocelot.cpbd.matching import match\n\n# Define magnetic lattice and initial Twiss parameters\nlat = MagneticLattice(sequence)\ntw = Twiss(beta_x=10, beta_y=5, alpha_x=0, alpha_y=0)\n\n# Define constraints and variables\nconstr = {elem1: {'beta_x': 10, 'beta_y': 5}, 'periodic': True}\nvars = [QF, QD]\n\n# Run matching\nresult = match(lat, constr, vars, tw)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"matching-with-global-and-soft-constraints",children:"Matching with Global and Soft Constraints"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"constr = {\n    elem1: {'alpha_x': ['>', 5], 'beta_y': 5},\n    'global': {'beta_x': ['<', 20]}\n}\nresult = match(lat, constr, vars, tw, method='bfgs', tol=1e-6)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Constraints"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Constraints can be \u201chard\u201d (exact values) or \u201csoft\u201d (inequalities with weights)."}),"\n",(0,t.jsx)(n.li,{children:"Global constraints affect the entire lattice, while local constraints apply to specific elements."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Weights"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The default weights prioritize periodicity and optical functions like beta and alpha. Users can define custom weight functions to adjust the optimization."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Methods"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"'simplex' is robust and works well for general cases but may be slower."}),"\n",(0,t.jsx)(n.li,{children:"'cg' and 'bfgs' are gradient-based and faster but require smooth functions."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The match function provides a flexible and powerful framework for beam optics matching and"})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(6540);const t={},l=i.createContext(t);function r(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);