"use strict";(self.webpackChunkocelot_website=self.webpackChunkocelot_website||[]).push([[9963],{5177:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"docu/physics-processes/beamtransform","title":"BeamTransform","description":"Beam Transform class","source":"@site/docs/docu/physics-processes/beamtransform.md","sourceDirName":"docu/physics-processes","slug":"/docu/physics-processes/beamtransform","permalink":"/docs/docu/physics-processes/beamtransform","draft":false,"unlisted":false,"editUrl":"https://github.com/ocelot-collab/ocelot-collab.github.io/tree/main/docs/docu/physics-processes/beamtransform.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"BeamTransform","description":"Beam Transform class"},"sidebar":"docsSidebar","previous":{"title":"Aperture Classes","permalink":"/docs/docu/physics-processes/apertures"},"next":{"title":"Beam Analysis","permalink":"/docs/docu/physics-processes/beam-analysis"}}');var r=n(4848),t=n(8453);const o={sidebar_position:9,title:"BeamTransform",description:"Beam Transform class"},i="BeamTransform",c={},d=[{value:"BeamTransform Class",id:"beamtransform-class",level:2},{value:"Parameters:",id:"parameters",level:3},{value:"Methods:",id:"methods",level:3},{value:"<code>__init__(self, tws=None, x_opt=None, y_opt=None, **kw)</code>",id:"__init__self-twsnone-x_optnone-y_optnone-kw",level:4},{value:"<code>twiss(self)</code>",id:"twissself",level:4},{value:"<code>apply(self, p_array, dz)</code>",id:"applyself-p_array-dz",level:4},{value:"Summary",id:"summary",level:2},{value:"Example of Usage",id:"example-of-usage",level:2}];function l(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"beamtransform",children:(0,r.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/physics_proc.py#L374",children:"BeamTransform"})})}),"\n",(0,r.jsxs)(s.p,{children:["This section provides documentation for the ",(0,r.jsx)(s.a,{href:"https://github.com/ocelot-collab/ocelot/blob/master/ocelot/cpbd/physics_proc.py#L374",children:(0,r.jsx)(s.code,{children:"BeamTransform"})})," class, which is used for beam matching using Twiss parameters.\nThe class applies beam matching based on the specified parameters, and removes offsets from the beam if required."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"beamtransform-class",children:"BeamTransform Class"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"BeamTransform"})," class performs beam matching by adjusting the beam's parameters (using the Twiss formalism) to meet the specified conditions. It includes an option to remove offsets from the beam and applies the matching transformation to the beam using the ",(0,r.jsx)(s.code,{children:"beam_matching"})," method."]}),"\n",(0,r.jsx)(s.h3,{id:"parameters",children:"Parameters:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"tws"})," (",(0,r.jsx)(s.code,{children:"Twiss"})," or ",(0,r.jsx)(s.code,{children:"None"}),"): A ",(0,r.jsx)(s.code,{children:"Twiss"})," object that contains the Twiss parameters for the beam. If ",(0,r.jsx)(s.code,{children:"None"}),", the Twiss parameters are derived from the ",(0,r.jsx)(s.code,{children:"x_opt"})," and ",(0,r.jsx)(s.code,{children:"y_opt"})," attributes."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"x_opt"})," (",(0,r.jsx)(s.code,{children:"list"})," or ",(0,r.jsx)(s.code,{children:"None"}),"): Obsolete list of Twiss parameters for the horizontal plane, ",(0,r.jsx)(s.code,{children:"[alpha, beta, mu (phase advance)]"}),". If ",(0,r.jsx)(s.code,{children:"None"}),", it uses ",(0,r.jsx)(s.code,{children:"tws"})," to get the parameters."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"y_opt"})," (",(0,r.jsx)(s.code,{children:"list"})," or ",(0,r.jsx)(s.code,{children:"None"}),"): Obsolete list of Twiss parameters for the vertical plane, ",(0,r.jsx)(s.code,{children:"[alpha, beta, mu (phase advance)]"}),". If ",(0,r.jsx)(s.code,{children:"None"}),", it uses ",(0,r.jsx)(s.code,{children:"tws"})," to get the parameters."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"remove_offsets"})," (",(0,r.jsx)(s.code,{children:"bool"}),"): If ",(0,r.jsx)(s.code,{children:"True"}),", offsets are removed from the beam before applying the matching. Default is ",(0,r.jsx)(s.code,{children:"True"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"bounds"})," (",(0,r.jsx)(s.code,{children:"list"}),"): Specifies the bounds in terms of sigmas (e.g., ",(0,r.jsx)(s.code,{children:"[-5, 5]"}),"). This defines the region of the beam to be matched. Default is ",(0,r.jsx)(s.code,{children:"[-5, 5]"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"slice"})," (",(0,r.jsx)(s.code,{children:"str"})," or ",(0,r.jsx)(s.code,{children:"None"}),"): Specifies a beam slice to be matched. If ",(0,r.jsx)(s.code,{children:"None"}),', the entire beam is considered. If set to "Imax" or "Emax", the beam is matched to that slice, and the ',(0,r.jsx)(s.code,{children:"bounds"})," parameter is ignored."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"methods",children:"Methods:"}),"\n",(0,r.jsx)(s.h4,{id:"__init__self-twsnone-x_optnone-y_optnone-kw",children:(0,r.jsx)(s.code,{children:"__init__(self, tws=None, x_opt=None, y_opt=None, **kw)"})}),"\n",(0,r.jsxs)(s.p,{children:["Constructor to initialize the ",(0,r.jsx)(s.code,{children:"BeamTransform"})," class. It sets the Twiss parameters, options for offset removal, bounds for beam matching, and slice type."]}),"\n",(0,r.jsx)(s.h4,{id:"twissself",children:(0,r.jsx)(s.code,{children:"twiss(self)"})}),"\n",(0,r.jsxs)(s.p,{children:["This property returns the ",(0,r.jsx)(s.code,{children:"Twiss"})," object used for the beam matching. If the ",(0,r.jsx)(s.code,{children:"tws"})," parameter is not provided, it constructs a new ",(0,r.jsx)(s.code,{children:"Twiss"})," object using the ",(0,r.jsx)(s.code,{children:"x_opt"})," and ",(0,r.jsx)(s.code,{children:"y_opt"})," values. A warning is logged if ",(0,r.jsx)(s.code,{children:"x_opt"})," and ",(0,r.jsx)(s.code,{children:"y_opt"})," are used (since they are obsolete)."]}),"\n",(0,r.jsx)(s.h4,{id:"applyself-p_array-dz",children:(0,r.jsx)(s.code,{children:"apply(self, p_array, dz)"})}),"\n",(0,r.jsxs)(s.p,{children:["Applies the beam transformation to the particle array (",(0,r.jsx)(s.code,{children:"p_array"}),") using the specified bounds and Twiss parameters. It invokes the ",(0,r.jsx)(s.code,{children:"beam_matching"})," method to perform the matching transformation."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"BeamTransform"})," class is designed for beam matching in particle accelerators using the Twiss formalism. It allows for adjusting the beam's parameters to achieve a desired beam profile, with options to remove offsets and specify the region of the"]}),"\n",(0,r.jsx)(s.p,{children:"beam to be matched. This class is particularly useful when optimizing beam parameters in accelerators or light sources. The class provides flexibility in defining beam boundaries and slices for matching, and handles both horizontal and vertical matching based on Twiss parameters."}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"example-of-usage",children:"Example of Usage"}),"\n",(0,r.jsxs)(s.p,{children:["The typical way to use ",(0,r.jsx)(s.code,{children:"BeamTransform"})," is to apply it as a standard physics process using the ",(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/navigator",children:(0,r.jsx)(s.code,{children:"Navigator"})})," class during beam ",(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/tracking",children:"tracking"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["However, it can also be used independently by directly calling its ",(0,r.jsx)(s.code,{children:"apply()"})," method on a ",(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/particle-array",children:(0,r.jsx)(s.code,{children:"ParticleArray"})}),".\nThis is somewhat unconventional but useful as a quick way to rematch the beam to desired ",(0,r.jsx)(s.a,{href:"/docs/docu/OCELOT%20fundamentals/twiss",children:"Twiss"})," parameters without requiring full tracking."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'from ocelot import *\n# Generate a test particle array\nparray = generate_parray(nparticles=10000)\n\n# Compute and print initial Twiss parameters\ntws = parray.get_twiss()\nprint("Twiss parameters of the initial beam:")\nprint(tws)\n\n# Define new target Twiss parameters for matching\ntws_new = Twiss(beta_x=10, alpha_x=-1, beta_y=20, alpha_y=1.3)\n\n# Create a BeamTransform to match the beam to the new Twiss parameters\nbt = BeamTransform(tws=tws_new)\n\n# Apply the transformation to the particle array\nbt.apply(parray, dz=0)\n\n# Compute and print the Twiss parameters after transformation\ntws_transf = parray.get_twiss()\nprint("Twiss parameters after BeamTransform:")\nprint(tws_transf)\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"    Twiss parameters of the initial beam:\n    emit_x  = 2.003184683249138e-09\n    emit_y  = 2.007487422659732e-09\n    beta_x  = 4.935702393228451\n    beta_y  = 5.02886241117081\n    alpha_x = -0.004596888719016395\n    alpha_y = -0.0009031158579342556\n    gamma_x = 0.20260968991118197\n    gamma_y = 0.19885229180200115\n    Dx      = 0.0\n    Dy      = 0.0\n    Dxp     = 0.0\n    Dyp     = 0.0\n    mux     = 0.0\n    muy     = 0.0\n    nu_x    = 0.0\n    nu_y    = 0.0\n    E       = 0.13\n    s        = 0.0\n    \n    Twiss parameters after BeamTransform:\n    emit_x  = 2.003184683454551e-09\n    emit_y  = 2.0074874230687637e-09\n    beta_x  = 10.000000007167706\n    beta_y  = 20.00000001187334\n    alpha_x = -0.9999999999849389\n    alpha_y = 1.2999999999949206\n    gamma_x = 0.19999999985363365\n    gamma_y = 0.13449999991949144\n    Dx      = 0.0\n    Dy      = 0.0\n    Dxp     = 0.0\n    Dyp     = 0.0\n    mux     = 0.0\n    muy     = 0.0\n    nu_x    = 0.0\n    nu_y    = 0.0\n    E       = 0.13\n    s        = 0.0\n"})})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>i});var a=n(6540);const r={},t=a.createContext(r);function o(e){const s=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(t.Provider,{value:s},e.children)}}}]);